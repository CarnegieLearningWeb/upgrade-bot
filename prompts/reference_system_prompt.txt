You are a software engineer with expertise in the Angular framework. Your mission is to provide design and development support for UpGrade, an open source A/B testing and feature flagging platform for education software.
When offering code suggestions or examples, ensure they align with the best practices and code patterns demonstrated in the provided 'reference' context.
Your responses should be focused, relevant, and grounded in the Angular MDC documentation and examples provided in the 'reference' folder. Avoid making assumptions or providing information not directly supported by the given 'reference' materials.

Context includes:
- 'reference': documentation and examples related to Angular MDC, serving as a guideline for implementing Material Design in an Angular project.

Please utilize this context:
{'reference': {'autocomplete': {'Filter autocomplete': {'CSS.css': '.example-form {\n  min-width: 150px;\n  max-width: 500px;\n  width: 100%;\n}\n\n.example-full-width {\n  width: 100%;\n}', 'HTML.html': '<form class="example-form">\n  <mat-form-field class="example-full-width">\n    <mat-label>Number</mat-label>\n    <input type="text"\n           placeholder="Pick one"\n           aria-label="Number"\n           matInput\n           [formControl]="myControl"\n           [matAutocomplete]="auto">\n    <mat-autocomplete #auto="matAutocomplete">\n      @for (option of filteredOptions | async; track option) {\n        <mat-option [value]="option">{{option}}</mat-option>\n      }\n    </mat-autocomplete>\n  </mat-form-field>\n</form>', 'TS.ts': "import {Component, OnInit} from '@angular/core';\nimport {FormControl, FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {Observable} from 'rxjs';\nimport {map, startWith} from 'rxjs/operators';\nimport {AsyncPipe} from '@angular/common';\nimport {MatAutocompleteModule} from '@angular/material/autocomplete';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\n/**\n * @title Filter autocomplete\n */\n@Component({\n  selector: 'autocomplete-filter-example',\n  templateUrl: 'autocomplete-filter-example.html',\n  styleUrl: 'autocomplete-filter-example.css',\n  standalone: true,\n  imports: [\n    FormsModule,\n    MatFormFieldModule,\n    MatInputModule,\n    MatAutocompleteModule,\n    ReactiveFormsModule,\n    AsyncPipe,\n  ],\n})\nexport class AutocompleteFilterExample implements OnInit {\n  myControl = new FormControl('');\n  options: string[] = ['One', 'Two', 'Three'];\n  filteredOptions: Observable<string[]>;\n\n  ngOnInit() {\n    this.filteredOptions = this.myControl.valueChanges.pipe(\n      startWith(''),\n      map(value => this._filter(value || '')),\n    );\n  }\n\n  private _filter(value: string): string[] {\n    const filterValue = value.toLowerCase();\n\n    return this.options.filter(option => option.toLowerCase().includes(filterValue));\n  }\n}"}, 'Require an autocomplete option to be selected': {'CSS.css': '.example-form {\n  min-width: 150px;\n  max-width: 500px;\n  width: 100%;\n  margin-top: 16px;\n}\n\n.example-full-width {\n  width: 100%;\n}', 'HTML.html': 'Control value: {{myControl.value || \'empty\'}}\n\n<form class="example-form">\n  <mat-form-field class="example-full-width">\n    <mat-label>Number</mat-label>\n    <input #input\n           type="text"\n           placeholder="Pick one"\n           matInput\n           [formControl]="myControl"\n           [matAutocomplete]="auto"\n           (input)="filter()"\n           (focus)="filter()">\n    <mat-autocomplete requireSelection #auto="matAutocomplete">\n      @for (option of filteredOptions; track option) {\n        <mat-option [value]="option">{{option}}</mat-option>\n      }\n    </mat-autocomplete>\n  </mat-form-field>\n</form>', 'TS.ts': "import {Component, ElementRef, ViewChild} from '@angular/core';\nimport {FormControl, FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {AsyncPipe} from '@angular/common';\nimport {MatAutocompleteModule} from '@angular/material/autocomplete';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\n/**\n * @title Require an autocomplete option to be selected\n */\n@Component({\n  selector: 'autocomplete-require-selection-example',\n  templateUrl: 'autocomplete-require-selection-example.html',\n  styleUrl: 'autocomplete-require-selection-example.css',\n  standalone: true,\n  imports: [\n    FormsModule,\n    MatFormFieldModule,\n    MatInputModule,\n    MatAutocompleteModule,\n    ReactiveFormsModule,\n    AsyncPipe,\n  ],\n})\nexport class AutocompleteRequireSelectionExample {\n  @ViewChild('input') input: ElementRef<HTMLInputElement>;\n  myControl = new FormControl('');\n  options: string[] = ['One', 'Two', 'Three', 'Four', 'Five'];\n  filteredOptions: string[];\n\n  constructor() {\n    this.filteredOptions = this.options.slice();\n  }\n\n  filter(): void {\n    const filterValue = this.input.nativeElement.value.toLowerCase();\n    this.filteredOptions = this.options.filter(o => o.toLowerCase().includes(filterValue));\n  }\n}"}, 'overview.txt': 'The autocomplete is a normal text input enhanced by a panel of suggested options.\n\n Simple autocomplete\nStart by creating the autocomplete panel and the options displayed inside it. Each option should be defined by a mat-option tag. Set each option\'s value property to whatever you\'d like the value of the text input to be when that option is selected.\n\n<mat-autocomplete #auto="matAutocomplete">\n  @for (option of options; track option) {\n    <mat-option [value]="option">{{option}}</mat-option>\n  }\n</mat-autocomplete>\nNext, create the input and set the matAutocomplete input to refer to the template reference we assigned to the autocomplete. Let\'s assume you\'re using the formControl directive from ReactiveFormsModule to track the value of the input.\n\nNote: It is possible to use template-driven forms instead, if you prefer. We use reactive forms in this example because it makes subscribing to changes in the input\'s value easy. For this example, be sure to import ReactiveFormsModule from @angular/forms into your NgModule. If you are unfamiliar with using reactive forms, you can read more about the subject in the Angular documentation.\n\nNow we\'ll need to link the text input to its panel. We can do this by exporting the autocomplete panel instance into a local template variable (here we called it "auto"), and binding that variable to the input\'s matAutocomplete property.\n\n<input type="text"\n       placeholder="Pick one"\n       aria-label="Number"\n       matInput\n       [formControl]="myControl"\n       [matAutocomplete]="auto">\n Adding a custom filter\nAt this point, the autocomplete panel should be toggleable on focus and options should be selectable. But if we want our options to filter when we type, we need to add a custom filter.\n\nYou can filter the options in any way you like based on the text input*. Here we will perform a simple string test on the option value to see if it matches the input value, starting from the option\'s first letter. We already have access to the built-in valueChanges Observable on the FormControl, so we can simply map the text input\'s values to the suggested options by passing them through this filter. The resulting Observable, filteredOptions, can be added to the template in place of the options property using the async pipe.\n\nBelow we are also priming our value change stream with an empty string so that the options are filtered by that value on init (before there are any value changes).\n\n*For optimal accessibility, you may want to consider adding text guidance on the page to explain filter criteria. This is especially helpful for screenreader users if you\'re using a non-standard filter that doesn\'t limit matches to the beginning of the string.\n\n Setting separate control and display values\nIf you want the option\'s control value (what is saved in the form) to be different than the option\'s display value (what is displayed in the text field), you\'ll need to set the displayWith property on your autocomplete element. A common use case for this might be if you want to save your data as an object, but display just one of the option\'s string properties.\n\nTo make this work, create a function on your component class that maps the control value to the desired display value. Then bind it to the autocomplete\'s displayWith property.\n\n Require an option to be selected\nBy default, the autocomplete will accept the value that the user typed into the input field. Instead, if you want to instead ensure that an option from the autocomplete was selected, you can enable the requireSelection input on mat-autocomplete. This will change the behavior of the autocomplete in the following ways:\n\nIf the user opens the autocomplete, changes its value, but doesn\'t select anything, the autocomplete value will be reset back to null.\nIf the user opens and closes the autocomplete without changing the value, the old value will be preserved.\nThis behavior can be configured globally using the MAT_AUTOCOMPLETE_DEFAULT_OPTIONS injection token.\n\n Automatically highlighting the first option\nIf your use case requires for the first autocomplete option to be highlighted when the user opens the panel, you can do so by setting the autoActiveFirstOption input on the mat-autocomplete component. This behavior can be configured globally using the MAT_AUTOCOMPLETE_DEFAULT_OPTIONS injection token.\n\n Autocomplete on a custom input element\nWhile mat-autocomplete supports attaching itself to a mat-form-field, you can also set it on any other input element using the matAutocomplete attribute. This allows you to customize what the input looks like without having to bring in the extra functionality from mat-form-field.\n\n Attaching the autocomplete panel to a different element\nBy default the autocomplete panel will be attached to your input element, however in some cases you may want it to attach to a different container element. You can change the element that the autocomplete is attached to using the matAutocompleteOrigin directive together with the matAutocompleteConnectedTo input:\n\n<div class="custom-wrapper-example" matAutocompleteOrigin #origin="matAutocompleteOrigin">\n  <input\n    matInput\n    [formControl]="myControl"\n    [matAutocomplete]="auto"\n    [matAutocompleteConnectedTo]="origin">\n</div>\n\n<mat-autocomplete #auto="matAutocomplete">\n  @for (option of options; track option) {\n    <mat-option [value]="option">{{option}}</mat-option>\n  }\n</mat-autocomplete>\n\n Option groups\nmat-option can be collected into groups using the mat-optgroup element:\n\n  <mat-autocomplete #autoGroup="matAutocomplete">\n    @for (group of stateGroupOptions | async; track group) {\n      <mat-optgroup [label]="group.letter">\n        @for (name of group.names; track name) {\n          <mat-option [value]="name">{{name}}</mat-option>\n        }\n      </mat-optgroup>\n    }\n</mat-autocomplete>\n Accessibility\nMatAutocomplete implements the ARIA combobox interaction pattern. The text input trigger specifies role="combobox" while the content of the pop-up applies role="listbox". Because of this listbox pattern, you should not put other interactive controls, such as buttons or checkboxes, inside an autocomplete option. Nesting interactive controls like this interferes with most assistive technology.\nAlways provide an accessible label for the autocomplete. This can be done by using a <mat-label> inside of <mat-form-field>, a native <label> element, the aria-label attribute, or the aria-labelledby attribute.\nMatAutocomplete preserves focus on the text trigger, using aria-activedescendant to support navigation though the autocomplete options.\nBy default, MatAutocomplete displays a checkmark to identify the selected item. While you can hide the checkmark indicator via hideSingleSelectionIndicator, this makes the component less accessible by making it harder or impossible for users to visually identify selected items.'}, 'button': {'Basic buttons': {'CSS.css': 'section {\n  display: table;\n}\n\n.example-label {\n  display: table-cell;\n  font-size: 14px;\n  margin-left: 8px;\n  min-width: 120px;\n}\n\n.example-button-row {\n  display: table-cell;\n  max-width: 600px;\n}\n\n.example-button-row .mat-mdc-button-base {\n  margin: 8px 8px 8px 0;\n}\n\n.example-flex-container {\n  display: flex;\n  justify-content: space-between;\n  flex-wrap: wrap;\n}\n\n.example-button-container {\n  display: flex;\n  justify-content: center;\n  width: 120px;\n}', 'HTML.html': '<section>\n  <div class="example-label">Basic</div>\n  <div class="example-button-row">\n    <button mat-button>Basic</button>\n    <button mat-button color="primary">Primary</button>\n    <button mat-button color="accent">Accent</button>\n    <button mat-button color="warn">Warn</button>\n    <button mat-button disabled>Disabled</button>\n    <a mat-button href="https://www.google.com/" target="_blank">Link</a>\n  </div>\n</section>\n<mat-divider></mat-divider>\n<section>\n  <div class="example-label">Raised</div>\n  <div class="example-button-row">\n    <button mat-raised-button>Basic</button>\n    <button mat-raised-button color="primary">Primary</button>\n    <button mat-raised-button color="accent">Accent</button>\n    <button mat-raised-button color="warn">Warn</button>\n    <button mat-raised-button disabled>Disabled</button>\n    <a mat-raised-button href="https://www.google.com/" target="_blank">Link</a>\n  </div>\n</section>\n<mat-divider></mat-divider>\n<section>\n  <div class="example-label">Stroked</div>\n  <div class="example-button-row">\n    <button mat-stroked-button>Basic</button>\n    <button mat-stroked-button color="primary">Primary</button>\n    <button mat-stroked-button color="accent">Accent</button>\n    <button mat-stroked-button color="warn">Warn</button>\n    <button mat-stroked-button disabled>Disabled</button>\n    <a mat-stroked-button href="https://www.google.com/" target="_blank">Link</a>\n  </div>\n</section>\n<mat-divider></mat-divider>\n<section>\n  <div class="example-label">Flat</div>\n  <div class="example-button-row">\n    <button mat-flat-button>Basic</button>\n    <button mat-flat-button color="primary">Primary</button>\n    <button mat-flat-button color="accent">Accent</button>\n    <button mat-flat-button color="warn">Warn</button>\n    <button mat-flat-button disabled>Disabled</button>\n    <a mat-flat-button href="https://www.google.com/" target="_blank">Link</a>\n  </div>\n</section>\n<mat-divider></mat-divider>\n<section>\n  <div class="example-label">Icon</div>\n  <div class="example-button-row">\n    <div class="example-flex-container">\n      <button mat-icon-button aria-label="Example icon button with a vertical three dot icon">\n        <mat-icon>more_vert</mat-icon>\n      </button>\n      <button mat-icon-button color="primary" aria-label="Example icon button with a home icon">\n        <mat-icon>home</mat-icon>\n      </button>\n      <button mat-icon-button color="accent" aria-label="Example icon button with a menu icon">\n        <mat-icon>menu</mat-icon>\n      </button>\n      <button mat-icon-button color="warn" aria-label="Example icon button with a heart icon">\n        <mat-icon>favorite</mat-icon>\n      </button>\n      <button mat-icon-button disabled aria-label="Example icon button with a open in new tab icon">\n        <mat-icon>open_in_new</mat-icon>\n      </button>\n    </div>\n  </div>\n</section>\n<mat-divider></mat-divider>\n<section>\n  <div class="example-label">FAB</div>\n  <div class="example-button-row">\n    <div class="example-flex-container">\n      <div class="example-button-container">\n        <button mat-fab color="primary" aria-label="Example icon button with a delete icon">\n          <mat-icon>delete</mat-icon>\n        </button>\n      </div>\n      <div class="example-button-container">\n        <button mat-fab color="accent" aria-label="Example icon button with a bookmark icon">\n          <mat-icon>bookmark</mat-icon>\n        </button>\n      </div>\n      <div class="example-button-container">\n        <button mat-fab color="warn" aria-label="Example icon button with a home icon">\n          <mat-icon>home</mat-icon>\n        </button>\n      </div>\n      <div class="example-button-container">\n        <button mat-fab disabled aria-label="Example icon button with a heart icon">\n          <mat-icon>favorite</mat-icon>\n        </button>\n      </div>\n    </div>\n  </div>\n</section>\n<mat-divider></mat-divider>\n<section>\n  <div class="example-label">Mini FAB</div>\n  <div class="example-button-row">\n    <div class="example-flex-container">\n      <div class="example-button-container">\n        <button mat-mini-fab color="primary" aria-label="Example icon button with a menu icon">\n          <mat-icon>menu</mat-icon>\n        </button>\n      </div>\n      <div class="example-button-container">\n        <button mat-mini-fab color="accent" aria-label="Example icon button with a plus one icon">\n          <mat-icon>plus_one</mat-icon>\n        </button>\n      </div>\n      <div class="example-button-container">\n        <button mat-mini-fab color="warn" aria-label="Example icon button with a filter list icon">\n          <mat-icon>filter_list</mat-icon>\n        </button>\n      </div>\n      <div class="example-button-container">\n        <button mat-mini-fab disabled aria-label="Example icon button with a home icon">\n          <mat-icon>home</mat-icon>\n        </button>\n      </div>\n    </div>\n  </div>\n</section>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatIconModule} from '@angular/material/icon';\nimport {MatDividerModule} from '@angular/material/divider';\nimport {MatButtonModule} from '@angular/material/button';\n\n/**\n * @title Basic buttons\n */\n@Component({\n  selector: 'button-overview-example',\n  templateUrl: 'button-overview-example.html',\n  styleUrl: 'button-overview-example.css',\n  standalone: true,\n  imports: [MatButtonModule, MatDividerModule, MatIconModule],\n})\nexport class ButtonOverviewExample {}"}, 'overview.txt': 'Angular Material buttons are native <button> or <a> elements enhanced with Material Design styling and ink ripples.\nNative <button> and <a> elements are always used in order to provide the most straightforward and accessible experience for users. A <button> element should be used whenever some action is performed. An <a> element should be used whenever the user will navigate to another view.\nThere are several button variants, each applied as an attribute:\n\nAttribute\tDescription\nmat-button\tRectangular text button w/ no elevation\nmat-raised-button\tRectangular contained button w/ elevation\nmat-flat-button\tRectangular contained button w/ no elevation\nmat-stroked-button\tRectangular outlined button w/ no elevation\nmat-icon-button\tCircular button with a transparent background, meant to contain an icon\nmat-fab\tCircular button w/ elevation, defaults to theme\'s accent color\nmat-mini-fab\tSame as mat-fab but smaller\n\n Theming\nButtons can be colored in terms of the current theme using the color property to set the background color to primary, accent, or warn.\n\n Capitalization\nAccording to the Material design spec button text has to be capitalized, however we have opted not to capitalize buttons automatically via text-transform: uppercase, because it can cause issues in certain locales. It is also worth noting that using ALL CAPS in the text itself causes issues for screen-readers, which will read the text character-by-character. We leave the decision of how to approach this to the consuming app.\n\n Extended fab buttons\nTraditional fab buttons are circular and only have space for a single icon. However, you can add the extended attribute to allow the fab to expand into a rounded rectangle shape with space for a text label in addition to the icon. Only full sized fabs support the extended attribute, mini fabs do not.\n\n<button mat-fab extended>\n  <mat-icon>home</mat-icon>\n  Home\n</button>\n Interactive disabled buttons\nNative disabled <button> elements cannot receive focus and do not dispatch any events. This can be problematic in some cases because it can prevent the app from telling the user why the button is disabled. You can use the disabledInteractive input to style the button as disabled but allow for it to receive focus and dispatch events. The button will have aria-disabled="true" for assistive technology. The behavior can be configured globally through the MAT_BUTTON_CONFIG injection token.\n\nNote: Using the disabledInteractive input can result in buttons that previously prevented actions to no longer do so, for example a submit button in a form. When using this input, you should guard against such cases in your component.\n\n Accessibility\nAngular Material uses native <button> and <a> elements to ensure an accessible experience by default. A <button> element should be used for any interaction that performs an action on the current page. An <a> element should be used for any interaction that navigates to another URL. All standard accessibility best practices for buttons and anchors apply to MatButton.\n\n Disabling anchors\nMatAnchor supports disabling an anchor in addition to the features provided by the native <a> element. When you disable an anchor, the component sets aria-disabled="true" and tabindex="-1". Always test disabled anchors in your application to ensure compatibility with any assistive technology your application supports.\n\n Buttons with icons\nButtons or links containing only icons (such as mat-fab, mat-mini-fab, and mat-icon-button) should be given a meaningful label via aria-label or aria-labelledby. See the documentation for MatIcon for more information on using icons in buttons.'}, 'card': {'Basic cards': {'HTML.html': '<mat-card>\n  <mat-card-content>Simple card</mat-card-content>\n</mat-card>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatCardModule} from '@angular/material/card';\n\n/**\n * @title Basic cards\n */\n@Component({\n  selector: 'card-overview-example',\n  templateUrl: 'card-overview-example.html',\n  standalone: true,\n  imports: [MatCardModule],\n})\nexport class CardOverviewExample {}"}, 'Card with actions alignment option': {'HTML.html': '<mat-card>\n  <mat-card-header>\n    <mat-card-title>Actions Buttons</mat-card-title>\n    <mat-card-subtitle>Start</mat-card-subtitle>\n  </mat-card-header>\n  <mat-card-actions>\n    <button mat-button>LIKE</button>\n    <button mat-button>SHARE</button>\n  </mat-card-actions>\n</mat-card>\n<br>\n<mat-card>\n  <mat-card-header>\n    <mat-card-title>Actions Buttons</mat-card-title>\n    <mat-card-subtitle>End</mat-card-subtitle>\n  </mat-card-header>\n  <mat-card-actions align="end">\n    <button mat-button>LIKE</button>\n    <button mat-button>SHARE</button>\n  </mat-card-actions>\n</mat-card>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatButtonModule} from '@angular/material/button';\nimport {MatCardModule} from '@angular/material/card';\n\n/**\n * @title Card with actions alignment option\n */\n@Component({\n  selector: 'card-actions-example',\n  templateUrl: 'card-actions-example.html',\n  standalone: true,\n  imports: [MatCardModule, MatButtonModule],\n})\nexport class CardActionsExample {}"}, 'Card with footer': {'CSS.css': '.example-card {\n  max-width: 400px;\n}', 'HTML.html': '<mat-card class="example-card">\n  <mat-card-header>\n    <mat-card-subtitle>Dog Breed</mat-card-subtitle>\n    <mat-card-title>Shiba Inu</mat-card-title>\n  </mat-card-header>\n  <mat-card-content>\n    <p>This card has divider and indeterminate progress as footer</p>\n    <p>{{ longText }}</p>\n    <mat-divider></mat-divider>\n  </mat-card-content>\n  <mat-card-actions>\n    <button mat-button>LIKE</button>\n    <button mat-button>SHARE</button>\n  </mat-card-actions>\n  <mat-card-footer>\n    <mat-progress-bar mode="indeterminate"></mat-progress-bar>\n  </mat-card-footer>\n</mat-card>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatProgressBarModule} from '@angular/material/progress-bar';\nimport {MatButtonModule} from '@angular/material/button';\nimport {MatDividerModule} from '@angular/material/divider';\nimport {MatCardModule} from '@angular/material/card';\n\n/**\n * @title Card with footer\n */\n@Component({\n  selector: 'card-footer-example',\n  templateUrl: 'card-footer-example.html',\n  styleUrl: 'card-footer-example.css',\n  standalone: true,\n  imports: [MatCardModule, MatDividerModule, MatButtonModule, MatProgressBarModule],\n})\nexport class CardFooterExample {\n  longText = `The Shiba Inu is the smallest of the six original and distinct spitz breeds of dog\n  from Japan. A small, agile dog that copes very well with mountainous terrain, the Shiba Inu was\n  originally bred for hunting.`;\n}"}, 'Card with sub-title': {'CSS.css': '.example-card {\n  max-width: 400px;\n}', 'HTML.html': '<mat-card class="example-card">\n  <mat-card-header>\n    <mat-card-title>Shiba Inu</mat-card-title>\n    <mat-card-subtitle>Dog Breed</mat-card-subtitle>\n  </mat-card-header>\n  <mat-card-content>\n    <p>This card indeterminates progress bar.</p>\n    <p>{{longText}}</p>\n  </mat-card-content>\n  <mat-card-actions>\n    <button mat-button>LIKE</button>\n    <button mat-button>SHARE</button>\n  </mat-card-actions>\n</mat-card>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatButtonModule} from '@angular/material/button';\nimport {MatCardModule} from '@angular/material/card';\n\n/**\n * @title Card with sub-title\n */\n@Component({\n  selector: 'card-subtitle-example',\n  templateUrl: 'card-subtitle-example.html',\n  styleUrl: 'card-subtitle-example.css',\n  standalone: true,\n  imports: [MatCardModule, MatButtonModule],\n})\nexport class CardSubtitleExample {\n  longText = `The Shiba Inu is the smallest of the six original and distinct spitz breeds of dog\n  from Japan. A small, agile dog that copes very well with mountainous terrain, the Shiba Inu was\n  originally bred for hunting.`;\n}"}, 'overview.txt': '<mat-card> is a content container for text, photos, and actions in the context of a single subject.\n\n Basic card sections\nThe most basic card needs only an <mat-card> element with some content. However, Angular Material provides a number of preset sections that you can use inside a <mat-card>:\n\nElement\tDescription\n<mat-card-header>\tSection anchored to the top of the card (adds padding)\n<mat-card-content>\tPrimary card content (adds padding)\n<img mat-card-image>\tCard image. Stretches the image to the container width\n<mat-card-actions>\tContainer for buttons at the bottom of the card (adds padding)\n<mat-card-footer>\tSection anchored to the bottom of the card\nThese elements primary serve as pre-styled content containers without any additional APIs. However, the align property on <mat-card-actions> can be used to position the actions at the \'start\' or \'end\' of the container.\n\n Card padding\nThe <mat-card> element itself does not add any padding around its content. This allows developers to customize the padding to their liking by applying padding to the elements they put in the card.\n\nIn many cases developers may just want the standard padding specified in the Material Design spec. In this case, the <mat-card-header>, <mat-card-content>, and <mat-card-footer> sections can be used.\n\n<mat-card-content> adds standard padding along its sides, as well as along the top if it is the first element in the <mat-card>, and along the bottom if it is the last element in the <mat-card>.\n<mat-card-header> adds standard padding along its sides and top.\n<mat-card-actions> adds padding appropriate for the action buttons at the bottom of a card.\n\n Card headers\nA <mat-card-header> can contain any content, but there are several predefined elements that can be used to create a rich header to a card. These include:\n\nElement\tDescription\n<mat-card-title>\tA title within the header\n<mat-card-subtitle>\tA subtitle within the header\n<img mat-card-avatar>\tAn image used as an avatar within the header\nIn addition to using <mat-card-title> and <mat-card-subtitle> directly within the <mat-card-header>, they can be further nested inside a <mat-card-title-group> in order arrange them with a (non-avatar) image.\n\n Title groups\n<mat-card-title-group> can be used to combine a title, subtitle, and image into a single section. This element can contain:\n\n<mat-card-title>\n<mat-card-subtitle>\nOne of:\n<img mat-card-sm-image>\n<img mat-card-md-image>\n<img mat-card-lg-image>\n\n Accessibility\nCards serve a wide variety of scenarios and may contain many different types of content. Due to this flexible nature, the appropriate accessibility treatment depends on how you use <mat-card>.\n\n Group, region, and landmarks\nThere are several ARIA roles that communicate that a portion of the UI represents some semantically meaningful whole. Depending on what the content of the card means to your application, you can apply one of role="group", role="region", or one of the landmark roles to the <mat-card> element.\n\nYou do not need to apply a role when using a card as a purely decorative container that does not convey a meaningful grouping of related content for a single subject. In these cases, the content of the card should follow standard practices for document content.\n\n Focus\nDepending on how cards are used, it may be appropriate to apply a tabindex to the <mat-card> element.\n\nIf cards are a primary mechanism through which user interacts with the application, tabindex="0" may be appropriate.\nIf attention can be sent to the card, but it\'s not part of the document flow, tabindex="-1" may be appropriate.\nIf the card acts as a purely decorative container, it does not need to be tabbable. In this case, the card content should follow normal best practices for tab order.\nAlways test your application to verify the behavior that works best for your users.'}, 'checkbox': {'Basic checkboxes': {'CSS.css': '.example-section {\n  margin: 12px 0;\n}\n\n.example-margin {\n  margin: 0 12px;\n}\n\nul {\n  list-style-type: none;\n  margin-top: 4px;\n}', 'HTML.html': '<section class="example-section">\n  <mat-checkbox class="example-margin">Check me!</mat-checkbox>\n  <mat-checkbox class="example-margin" [disabled]="true">Disabled</mat-checkbox>\n</section>\n\n<section class="example-section">\n  <span class="example-list-section">\n    <mat-checkbox class="example-margin"\n                  [checked]="allComplete"\n                  [color]="task.color"\n                  [indeterminate]="someComplete()"\n                  (change)="setAll($event.checked)">\n      {{task.name}}\n    </mat-checkbox>\n  </span>\n  <span class="example-list-section">\n    <ul>\n      @for (subtask of task.subtasks; track subtask) {\n        <li>\n          <mat-checkbox [(ngModel)]="subtask.completed"\n                        [color]="subtask.color"\n                        (ngModelChange)="updateAllComplete()">\n            {{subtask.name}}\n          </mat-checkbox>\n        </li>\n      }\n    </ul>\n  </span>\n</section>', 'TS.ts': "import {Component} from '@angular/core';\nimport {ThemePalette} from '@angular/material/core';\nimport {FormsModule} from '@angular/forms';\nimport {MatCheckboxModule} from '@angular/material/checkbox';\n\nexport interface Task {\n  name: string;\n  completed: boolean;\n  color: ThemePalette;\n  subtasks?: Task[];\n}\n\n/**\n * @title Basic checkboxes\n */\n@Component({\n  selector: 'checkbox-overview-example',\n  templateUrl: 'checkbox-overview-example.html',\n  styleUrl: 'checkbox-overview-example.css',\n  standalone: true,\n  imports: [MatCheckboxModule, FormsModule],\n})\nexport class CheckboxOverviewExample {\n  task: Task = {\n    name: 'Indeterminate',\n    completed: false,\n    color: 'primary',\n    subtasks: [\n      {name: 'Primary', completed: false, color: 'primary'},\n      {name: 'Accent', completed: false, color: 'accent'},\n      {name: 'Warn', completed: false, color: 'warn'},\n    ],\n  };\n\n  allComplete: boolean = false;\n\n  updateAllComplete() {\n    this.allComplete = this.task.subtasks != null && this.task.subtasks.every(t => t.completed);\n  }\n\n  someComplete(): boolean {\n    if (this.task.subtasks == null) {\n      return false;\n    }\n    return this.task.subtasks.filter(t => t.completed).length > 0 && !this.allComplete;\n  }\n\n  setAll(completed: boolean) {\n    this.allComplete = completed;\n    if (this.task.subtasks == null) {\n      return;\n    }\n    this.task.subtasks.forEach(t => (t.completed = completed));\n  }\n}"}, 'Checkboxes with reactive forms': {'CSS.css': '.example-section {\n  margin: 12px 0;\n}', 'HTML.html': '<section class="example-section" [formGroup]="toppings">\n  <h4>Select your toppings:</h4>\n  <p><mat-checkbox formControlName="pepperoni">Pepperoni</mat-checkbox></p>\n  <p><mat-checkbox formControlName="extracheese">Extra Cheese</mat-checkbox></p>\n  <p><mat-checkbox formControlName="mushroom">Mushroom</mat-checkbox></p>\n</section>\n\n<section class="example-section" [formGroup]="toppings">\n  <h4>You chose:</h4>\n  {{toppings.value | json}}\n</section>', 'TS.ts': "import {Component} from '@angular/core';\nimport {FormBuilder, FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {JsonPipe} from '@angular/common';\nimport {MatCheckboxModule} from '@angular/material/checkbox';\n\n/** @title Checkboxes with reactive forms */\n@Component({\n  selector: 'checkbox-reactive-forms-example',\n  templateUrl: 'checkbox-reactive-forms-example.html',\n  styleUrl: 'checkbox-reactive-forms-example.css',\n  standalone: true,\n  imports: [FormsModule, ReactiveFormsModule, MatCheckboxModule, JsonPipe],\n})\nexport class CheckboxReactiveFormsExample {\n  toppings = this._formBuilder.group({\n    pepperoni: false,\n    extracheese: false,\n    mushroom: false,\n  });\n\n  constructor(private _formBuilder: FormBuilder) {}\n}"}, 'overview.txt': '<mat-checkbox> provides the same functionality as a native <input type="checkbox"> enhanced with Material Design styling and animations.\n\n Checkbox label\nThe checkbox label is provided as the content to the <mat-checkbox> element. The label can be positioned before or after the checkbox by setting the labelPosition property to \'before\' or \'after\'.\nIf you don\'t want the label to appear next to the checkbox, you can use aria-label or aria-labelledby to specify an appropriate label.\n\n Use with @angular/forms\n<mat-checkbox> is compatible with @angular/forms and supports both FormsModule and ReactiveFormsModule.\n\n Indeterminate state\n<mat-checkbox> supports an indeterminate state, similar to the native <input type="checkbox">. While the indeterminate property of the checkbox is true, it will render as indeterminate regardless of the checked value. Any interaction with the checkbox by a user (i.e., clicking) will remove the indeterminate state.\n\n Click action config\nWhen user clicks on the mat-checkbox, the default behavior is toggle checked value and set indeterminate to false. This behavior can be customized by providing a new value of MAT_CHECKBOX_DEFAULT_OPTIONS to the checkbox.\n\nproviders: [\n  {provide: MAT_CHECKBOX_DEFAULT_OPTIONS, useValue: { clickAction: \'noop\' } as MatCheckboxDefaultOptions}\n]\nThe possible values are:\n\n noop\nDo not change the checked value or indeterminate value. Developers have the power to implement customized click actions.\n\n check\nToggle checked value of the checkbox, ignore indeterminate value. If the checkbox is in indeterminate state, the checkbox will display as an indeterminate checkbox regardless the checked value.\n\n check-indeterminate\nDefault behavior of mat-checkbox. Always set indeterminate to false when user click on the mat-checkbox. This matches the behavior of native <input type="checkbox">.\n\n Theming\nThe color of a <mat-checkbox> can be changed by using the color property. By default, checkboxes use the theme\'s accent color. This can be changed to \'primary\' or \'warn\'.\n\n Accessibility\nMatCheckbox uses an internal <input type="checkbox"> to provide an accessible experience. This internal checkbox receives focus and is automatically labelled by the text content of the <mat-checkbox> element. Avoid adding other interactive controls into the content of <mat-checkbox>, as this degrades the experience for users of assistive technology.\n\nAlways provide an accessible label via aria-label or aria-labelledby for checkboxes without descriptive text content. For dynamic labels, MatCheckbox provides input properties for binding aria-label and aria-labelledby. This means that you should not use the attr. prefix when binding these properties, as demonstrated below.\n\n<mat-checkbox [aria-label]="isSubscribedToEmailsMessage">\n</mat-checkbox>'}, 'chips': {'Chips Autocomplete': {'CSS.css': '.example-chip-list {\n  width: 100%;\n}', 'HTML.html': '<form>\n  <mat-form-field class="example-chip-list">\n    <mat-label>Favorite Fruits</mat-label>\n    <mat-chip-grid #chipGrid aria-label="Fruit selection">\n      @for (fruit of fruits; track fruit) {\n        <mat-chip-row (removed)="remove(fruit)">\n          {{fruit}}\n          <button matChipRemove [attr.aria-label]="\'remove \' + fruit">\n            <mat-icon>cancel</mat-icon>\n          </button>\n        </mat-chip-row>\n      }\n    </mat-chip-grid>\n    <input placeholder="New Fruit..." #fruitInput [formControl]="fruitCtrl"\n      [matChipInputFor]="chipGrid" [matAutocomplete]="auto"\n      [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n      (matChipInputTokenEnd)="add($event)"/>\n    <mat-autocomplete #auto="matAutocomplete" (optionSelected)="selected($event)">\n      @for (fruit of filteredFruits | async; track fruit) {\n        <mat-option [value]="fruit">{{fruit}}</mat-option>\n      }\n    </mat-autocomplete>\n  </mat-form-field>\n</form>', 'TS.ts': "import {COMMA, ENTER} from '@angular/cdk/keycodes';\nimport {Component, ElementRef, ViewChild, inject} from '@angular/core';\nimport {FormControl, FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {MatAutocompleteSelectedEvent, MatAutocompleteModule} from '@angular/material/autocomplete';\nimport {MatChipInputEvent, MatChipsModule} from '@angular/material/chips';\nimport {Observable} from 'rxjs';\nimport {map, startWith} from 'rxjs/operators';\nimport {MatIconModule} from '@angular/material/icon';\nimport {AsyncPipe} from '@angular/common';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {LiveAnnouncer} from '@angular/cdk/a11y';\n\n/**\n * @title Chips Autocomplete\n */\n@Component({\n  selector: 'chips-autocomplete-example',\n  templateUrl: 'chips-autocomplete-example.html',\n  styleUrl: 'chips-autocomplete-example.css',\n  standalone: true,\n  imports: [\n    FormsModule,\n    MatFormFieldModule,\n    MatChipsModule,\n    MatIconModule,\n    MatAutocompleteModule,\n    ReactiveFormsModule,\n    AsyncPipe,\n  ],\n})\nexport class ChipsAutocompleteExample {\n  separatorKeysCodes: number[] = [ENTER, COMMA];\n  fruitCtrl = new FormControl('');\n  filteredFruits: Observable<string[]>;\n  fruits: string[] = ['Lemon'];\n  allFruits: string[] = ['Apple', 'Lemon', 'Lime', 'Orange', 'Strawberry'];\n\n  @ViewChild('fruitInput') fruitInput: ElementRef<HTMLInputElement>;\n\n  announcer = inject(LiveAnnouncer);\n\n  constructor() {\n    this.filteredFruits = this.fruitCtrl.valueChanges.pipe(\n      startWith(null),\n      map((fruit: string | null) => (fruit ? this._filter(fruit) : this.allFruits.slice())),\n    );\n  }\n\n  add(event: MatChipInputEvent): void {\n    const value = (event.value || '').trim();\n\n    // Add our fruit\n    if (value) {\n      this.fruits.push(value);\n    }\n\n    // Clear the input value\n    event.chipInput!.clear();\n\n    this.fruitCtrl.setValue(null);\n  }\n\n  remove(fruit: string): void {\n    const index = this.fruits.indexOf(fruit);\n\n    if (index >= 0) {\n      this.fruits.splice(index, 1);\n\n      this.announcer.announce(`Removed ${fruit}`);\n    }\n  }\n\n  selected(event: MatAutocompleteSelectedEvent): void {\n    this.fruits.push(event.option.viewValue);\n    this.fruitInput.nativeElement.value = '';\n    this.fruitCtrl.setValue(null);\n  }\n\n  private _filter(value: string): string[] {\n    const filterValue = value.toLowerCase();\n\n    return this.allFruits.filter(fruit => fruit.toLowerCase().includes(filterValue));\n  }\n}"}, 'Chips with form control': {'CSS.css': '.example-form-field {\n  width: 100%;\n}\n\n.example-button-container > button {\n  margin: 0 12px;\n}', 'HTML.html': '<div class="example-button-container">\n  <button mat-raised-button (click)="formControl.disable()">Disable form control</button>\n  <button mat-raised-button (click)="formControl.enable()">Enable form control</button>\n</div>\n<p>\n  <em>Enter video keywords</em>\n</p>\n<mat-form-field class="example-form-field">\n  <mat-label>Video keywords</mat-label>\n  <mat-chip-grid #chipGrid aria-label="Enter keywords" [formControl]="formControl" >\n    @for (keyword of keywords; track keyword) {\n      <mat-chip-row (removed)="removeKeyword(keyword)">\n        {{keyword}}\n        <button matChipRemove aria-label="\'remove \' + keyword">\n          <mat-icon>cancel</mat-icon>\n        </button>\n      </mat-chip-row>\n    }\n  </mat-chip-grid>\n  <input placeholder="New keyword..."\n          [matChipInputFor]="chipGrid"\n          (matChipInputTokenEnd)="add($event)"/>\n</mat-form-field>\n\n<p>\n  <strong>The following keywords are entered:</strong> {{formControl.value}}\n</p>', 'TS.ts': "import {Component, inject} from '@angular/core';\nimport {FormControl, FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {MatChipInputEvent, MatChipsModule} from '@angular/material/chips';\nimport {MatIconModule} from '@angular/material/icon';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatButtonModule} from '@angular/material/button';\nimport {LiveAnnouncer} from '@angular/cdk/a11y';\n\n/**\n * @title Chips with form control\n */\n@Component({\n  selector: 'chips-form-control-example',\n  templateUrl: 'chips-form-control-example.html',\n  styleUrl: 'chips-form-control-example.css',\n  standalone: true,\n  imports: [\n    MatButtonModule,\n    MatFormFieldModule,\n    MatChipsModule,\n    FormsModule,\n    ReactiveFormsModule,\n    MatIconModule,\n  ],\n})\nexport class ChipsFormControlExample {\n  keywords = ['angular', 'how-to', 'tutorial', 'accessibility'];\n  formControl = new FormControl(['angular']);\n\n  announcer = inject(LiveAnnouncer);\n\n  removeKeyword(keyword: string) {\n    const index = this.keywords.indexOf(keyword);\n    if (index >= 0) {\n      this.keywords.splice(index, 1);\n\n      this.announcer.announce(`removed ${keyword}`);\n    }\n  }\n\n  add(event: MatChipInputEvent): void {\n    const value = (event.value || '').trim();\n\n    // Add our keyword\n    if (value) {\n      this.keywords.push(value);\n    }\n\n    // Clear the input value\n    event.chipInput!.clear();\n  }\n}"}, 'Chips with input': {'CSS.css': '.example-chip-list {\n  width: 100%;\n}', 'HTML.html': '<mat-form-field class="example-chip-list">\n  <mat-label>Favorite Fruits</mat-label>\n  <mat-chip-grid #chipGrid aria-label="Enter fruits">\n    @for (fruit of fruits; track fruit) {\n      <mat-chip-row\n        (removed)="remove(fruit)"\n        [editable]="true"\n        (edited)="edit(fruit, $event)"\n        [aria-description]="\'press enter to edit \' + fruit.name">\n        {{fruit.name}}\n        <button matChipRemove [attr.aria-label]="\'remove \' + fruit.name">\n          <mat-icon>cancel</mat-icon>\n        </button>\n      </mat-chip-row>\n    }\n    <input placeholder="New fruit..."\n           [matChipInputFor]="chipGrid"\n           [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n           [matChipInputAddOnBlur]="addOnBlur"\n           (matChipInputTokenEnd)="add($event)"/>\n  </mat-chip-grid>\n</mat-form-field>', 'TS.ts': "import {COMMA, ENTER} from '@angular/cdk/keycodes';\nimport {Component, inject} from '@angular/core';\nimport {MatChipEditedEvent, MatChipInputEvent, MatChipsModule} from '@angular/material/chips';\nimport {MatIconModule} from '@angular/material/icon';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {LiveAnnouncer} from '@angular/cdk/a11y';\n\nexport interface Fruit {\n  name: string;\n}\n\n/**\n * @title Chips with input\n */\n@Component({\n  selector: 'chips-input-example',\n  templateUrl: 'chips-input-example.html',\n  styleUrl: 'chips-input-example.css',\n  standalone: true,\n  imports: [MatFormFieldModule, MatChipsModule, MatIconModule],\n})\nexport class ChipsInputExample {\n  addOnBlur = true;\n  readonly separatorKeysCodes = [ENTER, COMMA] as const;\n  fruits: Fruit[] = [{name: 'Lemon'}, {name: 'Lime'}, {name: 'Apple'}];\n\n  announcer = inject(LiveAnnouncer);\n\n  add(event: MatChipInputEvent): void {\n    const value = (event.value || '').trim();\n\n    // Add our fruit\n    if (value) {\n      this.fruits.push({name: value});\n    }\n\n    // Clear the input value\n    event.chipInput!.clear();\n  }\n\n  remove(fruit: Fruit): void {\n    const index = this.fruits.indexOf(fruit);\n\n    if (index >= 0) {\n      this.fruits.splice(index, 1);\n\n      this.announcer.announce(`Removed ${fruit}`);\n    }\n  }\n\n  edit(fruit: Fruit, event: MatChipEditedEvent) {\n    const value = event.value.trim();\n\n    // Remove fruit if it no longer has a name\n    if (!value) {\n      this.remove(fruit);\n      return;\n    }\n\n    // Edit existing fruit\n    const index = this.fruits.indexOf(fruit);\n    if (index >= 0) {\n      this.fruits[index].name = value;\n    }\n  }\n}"}, 'overview.txt': 'Chips allow users to view information, make selections, filter content, and enter data.\n\n Static Chips\nChips are always used inside a container. To create chips, start with a <mat-chip-set> element. Then, nest <mat-chip> elements inside the <mat-chip-set>.\nBy default, <mat-chip> renders a chip with Material Design styles applied. For a chip with no styles applied, use <mat-basic-chip>.\n\nHint: <mat-basic-chip> receives the mat-mdc-basic-chip CSS class in addition to the mat-mdc-chip class.\n\n Disabled appearance\nAlthough <mat-chip> is not interactive, you can set the disabled Input to give it disabled appearance.\n<mat-chip disabled>Orange</mat-chip>\n\n Selection Chips\nUse <mat-chip-listbox> and <mat-chip-option> for selecting one or many items from a list. Start with creating a <mat-chip-listbox> element. If the user may select more than one option, add the multiple attribute. Nest a <mat-chip-option> element inside the <mat-chip-listbox> for each available option.\n\n Disabled <mat-chip-option>\nUse the disabled Input to disable a <mat-chip-option>. This gives the <mat-chip-option> a disabled appearance and prevents the user from interacting with it.\n<mat-chip-option disabled>Orange</mat-chip-option>\n\n Chips connected to an input field\nUse <mat-chip-grid> and <mat-chip-row> for assisting users with text entry.\nChips are always used inside a container. To create chips connected to an input field, start by creating a <mat-chip-grid> as the container. Add an <input/> element, and register it to the <mat-chip-grid> by passing the matChipInputFor Input. Always use an <input/> element with <mat-chip-grid>. Nest a <mat-chip-row> element inside the <mat-chip-grid> for each piece of data entered by the user. An example of using chips for text input.\n\n Disabled <mat-chip-row>\nUse the disabled Input to disable a <mat-chip-row>. This gives the <mat-chip-row> a disabled appearance and prevents the user from interacting with it.\n<mat-chip-row disabled>Orange</mat-chip-row>\n\n Icons\nYou can add icons to chips to identify entities (like individuals) and provide additional functionality.\n\n Adding up to two icons with content projection\nYou can add two additional icons to an individual chip. A chip has two slots to display icons using content projection. All variants of chips support adding icons including <mat-chip>, <mat-chip-option>, and <mat-chip-row>.\nA chip has a front slot for adding an avatar image. To add an avatar, nest an element with matChipAvatar attribute inside of <mat-chip>.\n\nYou can add an additional icon to the back slot by nesting an element with either the matChipTrailingIcon or matChipRemove attribute.\n\n Remove Button\nSometimes the end user would like the ability to remove a chip. You can provide that functionality using matChipRemove. matChipRemove renders to the back slot of a chip and triggers the removed Output when clicked.\n\nTo create a remove button, nest a <button> element with matChipRemove attribute inside the <mat-chip-option>. Be sure to implement the removed Output.\n\n <mat-chip-option>\n  Orange\n  <button matChipRemove aria-label="Remove orange">\n    <mat-icon>cancel</mat-icon>\n  </button>\n</mat-chip-option>\nSee the accessibility section for best practices on implementing the removed Output and creating accessible icons.\n\n Orientation\nBy default, chips are displayed horizontally. To stack chips vertically, apply the mat-mdc-chip-set-stacked class to <mat-chip-set>, <mat-chip-listbox> or <mat-chip-grid>.\n\n Specifying global configuration defaults\nUse the MAT_CHIPS_DEFAULT_OPTIONS token to specify default options for the chips module.\n\n@NgModule({\n  providers: [\n    {\n      provide: MAT_CHIPS_DEFAULT_OPTIONS,\n      useValue: {\n        separatorKeyCodes: [COMMA, SPACE]\n      }\n    }\n  ]\n})\n Theming\nBy default, chips use the primary color. Specify the color property to change the color to accent or warn.\n\n Interaction Patterns\nThe chips components support 3 user interaction patterns, each with its own container and chip elements:\n\n Listbox\n<mat-chip-listbox> and <mat-chip-option> : These elements implement a listbox accessibility pattern. Use them to present set of user selectable options.\n<mat-chip-listbox aria-label="select a shirt size">\n  <mat-chip-option> Small </mat-chip-option>\n  <mat-chip-option> Medium </mat-chip-option>\n  <mat-chip-option> Large </mat-chip-option>\n</mat-chip-listbox>\n\n Text Entry\n<mat-chip-grid> and <mat-chip-row> : These elements implement a grid accessibility pattern. Use them as part of a free form input that allows users to enter text to add chips.\n\n<mat-form-field>\n  <mat-chip-grid #myChipGrid [(ngModel)]="mySelection"\n    aria-label="enter sandwich fillings">\n    @for (filling of fillings; track filling) {\n      <mat-chip-row (removed)="remove(filling)">\n        {{filling.name}}\n        <button matChipRemove>\n          <mat-icon>cancel</mat-icon>\n        </button>\n      </mat-chip-row>\n    }\n    <input [matChipInputFor]="myChipGrid"\n           [matChipInputSeparatorKeyCodes]="separatorKeysCodes"\n           (matChipInputTokenEnd)="add($event)" />\n  </mat-chip-grid>\n</mat-form-field>\n\n Static Content\n<mat-chip-set> and <mat-chip> as an unordered list : Present a list of items that are not interactive. This interaction pattern mimics using ul and li elements. Apply role="list" to the <mat-list>. Apply role="listitem" to each <mat-list-item>.\n\n<mat-chip-set role="list">\n  <mat-chip role="listitem"> Sugar </mat-chip>\n  <mat-chip role="listitem"> Spice </mat-chip>\n  <mat-chip role="listitem"> Everything Nice </mat-chip>\n</mat-chip-set>\n<mat-chip-set> and <mat-chip> : These elements do not implement any specific accessibility pattern. Add the appropriate accessibility depending on the context. Note that Angular Material does not intend <mat-chip>, <mat-basic-chip>, and <mat-chip-set> to be interactive.\n<mat-chip-set>\n  <mat-chip> John </mat-chip>\n  <mat-chip> Paul </mat-chip>\n  <mat-chip> James </mat-chip>\n</mat-chip-set>\n\n Accessibility\nThe Interaction Patterns section describes the three variants of chips available. Choose the chip variant that best matches your use case.\nFor both MatChipGrid and MatChipListbox, always apply an accessible label to the control via aria-label or aria-labelledby.\nAlways apply MatChipRemove to a <button> element, never a <mat-icon> element.\nWhen using MatChipListbox, never nest other interactive controls inside of the <mat-chip-option> element. Nesting controls degrades the experience for assistive technology users.\nBy default, MatChipListbox displays a checkmark to identify selected items. While you can hide the checkmark indicator for single-selection via hideSingleSelectionIndicator, this makes the component less accessible by making it harder or impossible for users to visually identify selected items.\nWhen a chip is editable, provide instructions to assistive technology how to edit the chip using a keyboard. One way to accomplish this is adding an aria-description attribute with instructions to press enter to edit the chip.'}, 'dialog': {'Dialog Overview': {'HTML.html': '<ol>\n  <li>\n    <mat-form-field>\n      <mat-label>What\'s your name?</mat-label>\n      <input matInput [(ngModel)]="name">\n    </mat-form-field>\n  </li>\n  <li>\n    <button mat-raised-button (click)="openDialog()">Pick one</button>\n  </li>\n  @if (animal) {\n    <li>You chose: <em>{{animal}}</em></li>\n  }\n</ol>', 'TS.ts': "import {Component, Inject} from '@angular/core';\nimport {\n  MatDialog,\n  MAT_DIALOG_DATA,\n  MatDialogRef,\n  MatDialogTitle,\n  MatDialogContent,\n  MatDialogActions,\n  MatDialogClose,\n} from '@angular/material/dialog';\nimport {MatButtonModule} from '@angular/material/button';\nimport {FormsModule} from '@angular/forms';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\nexport interface DialogData {\n  animal: string;\n  name: string;\n}\n\n/**\n * @title Dialog Overview\n */\n@Component({\n  selector: 'dialog-overview-example',\n  templateUrl: 'dialog-overview-example.html',\n  standalone: true,\n  imports: [MatFormFieldModule, MatInputModule, FormsModule, MatButtonModule],\n})\nexport class DialogOverviewExample {\n  animal: string;\n  name: string;\n\n  constructor(public dialog: MatDialog) {}\n\n  openDialog(): void {\n    const dialogRef = this.dialog.open(DialogOverviewExampleDialog, {\n      data: {name: this.name, animal: this.animal},\n    });\n\n    dialogRef.afterClosed().subscribe(result => {\n      console.log('The dialog was closed');\n      this.animal = result;\n    });\n  }\n}\n\n@Component({\n  selector: 'dialog-overview-example-dialog',\n  templateUrl: 'dialog-overview-example-dialog.html',\n  standalone: true,\n  imports: [\n    MatFormFieldModule,\n    MatInputModule,\n    FormsModule,\n    MatButtonModule,\n    MatDialogTitle,\n    MatDialogContent,\n    MatDialogActions,\n    MatDialogClose,\n  ],\n})\nexport class DialogOverviewExampleDialog {\n  constructor(\n    public dialogRef: MatDialogRef<DialogOverviewExampleDialog>,\n    @Inject(MAT_DIALOG_DATA) public data: DialogData,\n  ) {}\n\n  onNoClick(): void {\n    this.dialogRef.close();\n  }\n}", 'dialog-overview-example-dialog.html': '<h2 mat-dialog-title>Hi {{data.name}}</h2>\n<mat-dialog-content>\n  <p>What\'s your favorite animal?</p>\n  <mat-form-field>\n    <mat-label>Favorite Animal</mat-label>\n    <input matInput [(ngModel)]="data.animal">\n  </mat-form-field>\n</mat-dialog-content>\n<mat-dialog-actions>\n  <button mat-button (click)="onNoClick()">No Thanks</button>\n  <button mat-button [mat-dialog-close]="data.animal" cdkFocusInitial>Ok</button>\n</mat-dialog-actions>'}, 'Dialog elements': {'HTML.html': '<button mat-button (click)="openDialog()">Launch dialog</button>', 'TS.ts': "import {Component} from '@angular/core';\nimport {\n  MatDialog,\n  MatDialogActions,\n  MatDialogClose,\n  MatDialogContent,\n  MatDialogTitle,\n} from '@angular/material/dialog';\nimport {MatButtonModule} from '@angular/material/button';\n\n/**\n * @title Dialog elements\n */\n@Component({\n  selector: 'dialog-elements-example',\n  templateUrl: 'dialog-elements-example.html',\n  standalone: true,\n  imports: [MatButtonModule],\n})\nexport class DialogElementsExample {\n  constructor(public dialog: MatDialog) {}\n\n  openDialog() {\n    this.dialog.open(DialogElementsExampleDialog);\n  }\n}\n\n@Component({\n  selector: 'dialog-elements-example-dialog',\n  templateUrl: 'dialog-elements-example-dialog.html',\n  standalone: true,\n  imports: [MatDialogTitle, MatDialogContent, MatDialogActions, MatDialogClose, MatButtonModule],\n})\nexport class DialogElementsExampleDialog {}", 'dialog-elements-example-dialog.html': '<h2 mat-dialog-title>Dialog with elements</h2>\n<mat-dialog-content>This dialog showcases the title, close, content and actions elements.</mat-dialog-content>\n<mat-dialog-actions>\n  <button mat-button mat-dialog-close>Close</button>\n</mat-dialog-actions>'}, 'Dialog launched from a menu': {'HTML.html': '<button mat-button [matMenuTriggerFor]="menu" #menuTrigger>Menu</button>\n<mat-menu #menu="matMenu">\n  <button mat-menu-item (click)="openDialog()">Open dialog</button>\n</mat-menu>', 'TS.ts': "import {Component, ViewChild} from '@angular/core';\nimport {\n  MatDialog,\n  MatDialogActions,\n  MatDialogClose,\n  MatDialogContent,\n} from '@angular/material/dialog';\nimport {MatMenuTrigger, MatMenuModule} from '@angular/material/menu';\nimport {MatButtonModule} from '@angular/material/button';\n/**\n * @title Dialog launched from a menu\n */\n@Component({\n  selector: 'dialog-from-menu-example',\n  templateUrl: 'dialog-from-menu-example.html',\n  standalone: true,\n  imports: [MatButtonModule, MatMenuModule],\n})\nexport class DialogFromMenuExample {\n  @ViewChild('menuTrigger') menuTrigger: MatMenuTrigger;\n\n  constructor(public dialog: MatDialog) {}\n\n  openDialog() {\n    const dialogRef = this.dialog.open(DialogFromMenuExampleDialog, {restoreFocus: false});\n\n    // Manually restore focus to the menu trigger since the element that\n    // opens the dialog won't be in the DOM any more when the dialog closes.\n    dialogRef.afterClosed().subscribe(() => this.menuTrigger.focus());\n  }\n}\n\n@Component({\n  selector: 'dialog-from-menu-dialog',\n  templateUrl: 'dialog-from-menu-example-dialog.html',\n  standalone: true,\n  imports: [MatDialogContent, MatDialogActions, MatDialogClose, MatButtonModule],\n})\nexport class DialogFromMenuExampleDialog {}", 'dialog-from-menu-example-dialog.html': '<mat-dialog-content>\n  This is a dialog\n</mat-dialog-content>\n<mat-dialog-actions>\n  <button mat-button mat-dialog-close>Okay</button>\n</mat-dialog-actions>'}, 'Injecting data when opening a dialog': {'HTML.html': '<button mat-button (click)="openDialog()">Open dialog</button>', 'TS.ts': "import {Component, Inject} from '@angular/core';\nimport {\n  MatDialog,\n  MAT_DIALOG_DATA,\n  MatDialogTitle,\n  MatDialogContent,\n} from '@angular/material/dialog';\nimport {MatButtonModule} from '@angular/material/button';\n\nexport interface DialogData {\n  animal: 'panda' | 'unicorn' | 'lion';\n}\n\n/**\n * @title Injecting data when opening a dialog\n */\n@Component({\n  selector: 'dialog-data-example',\n  templateUrl: 'dialog-data-example.html',\n  standalone: true,\n  imports: [MatButtonModule],\n})\nexport class DialogDataExample {\n  constructor(public dialog: MatDialog) {}\n\n  openDialog() {\n    this.dialog.open(DialogDataExampleDialog, {\n      data: {\n        animal: 'panda',\n      },\n    });\n  }\n}\n\n@Component({\n  selector: 'dialog-data-example-dialog',\n  templateUrl: 'dialog-data-example-dialog.html',\n  standalone: true,\n  imports: [MatDialogTitle, MatDialogContent],\n})\nexport class DialogDataExampleDialog {\n  constructor(@Inject(MAT_DIALOG_DATA) public data: DialogData) {}\n}", 'dialog-data-example-dialog.html': "<h2 mat-dialog-title>Favorite Animal</h2>\n<mat-dialog-content>\n  My favorite animal is:\n  <ul>\n    <li>\n      @if (data.animal === 'panda') {\n        <span>&#10003;</span>\n      } Panda\n    </li>\n    <li>\n      @if (data.animal === 'unicorn') {\n        <span>&#10003;</span>\n      } Unicorn\n    </li>\n    <li>\n      @if (data.animal === 'lion') {\n        <span>&#10003;</span>\n      } Lion\n    </li>\n  </ul>\n</mat-dialog-content>"}, 'overview.txt': 'The MatDialog service can be used to open modal dialogs with Material Design styling and animations.\n\nA dialog is opened by calling the open method with a component to be loaded and an optional config object. The open method will return an instance of MatDialogRef:\n\nlet dialogRef = dialog.open(UserProfileComponent, {\n  height: \'400px\',\n  width: \'600px\',\n});\nThe MatDialogRef provides a handle on the opened dialog. It can be used to close the dialog and to receive notifications when the dialog has been closed. Any notification Observables will complete when the dialog closes.\n\ndialogRef.afterClosed().subscribe(result => {\n  console.log(`Dialog result: ${result}`); // Pizza!\n});\n\ndialogRef.close(\'Pizza!\');\nComponents created via MatDialog can inject MatDialogRef and use it to close the dialog in which they are contained. When closing, an optional result value can be provided. This result value is forwarded as the result of the afterClosed Observable.\n\n@Component({/* ... */})\nexport class YourDialog {\n  constructor(public dialogRef: MatDialogRef<YourDialog>) { }\n\n  closeDialog() {\n    this.dialogRef.close(\'Pizza!\');\n  }\n}\n Specifying global configuration defaults\nDefault dialog options can be specified by providing an instance of MatDialogConfig for MAT_DIALOG_DEFAULT_OPTIONS in your application\'s root module.\n\n@NgModule({\n  providers: [\n    {provide: MAT_DIALOG_DEFAULT_OPTIONS, useValue: {hasBackdrop: false}}\n  ]\n})\n Sharing data with the Dialog component.\nIf you want to share data with your dialog, you can use the data option to pass information to the dialog component.\n\nlet dialogRef = dialog.open(YourDialog, {\n  data: { name: \'austin\' },\n});\nTo access the data in your dialog component, you have to use the MAT_DIALOG_DATA injection token:\n\nimport {Component, Inject} from \'@angular/core\';\nimport {MAT_DIALOG_DATA} from \'@angular/material/dialog\';\n\n@Component({\n  selector: \'your-dialog\',\n  template: \'passed in {{ data.name }}\',\n})\nexport class YourDialog {\n  constructor(@Inject(MAT_DIALOG_DATA) public data: {name: string}) { }\n}\nNote that if you\'re using a template dialog (one that was opened with a TemplateRef), the data will be available implicitly in the template:\n\n<ng-template let-data>\n  Hello, {{data.name}}\n</ng-template>\nInjecting data when opening a dialog\n Dialog content\nSeveral directives are available to make it easier to structure your dialog content:\n\nName\tDescription\nmat-dialog-title\t[Attr] Dialog title, applied to a heading element (e.g., <h1>, <h2>)\n<mat-dialog-content>\tPrimary scrollable content of the dialog.\n<mat-dialog-actions>\tContainer for action buttons at the bottom of the dialog. Button alignment can be controlled via the align attribute which can be set to end and center.\nmat-dialog-close\t[Attr] Added to a <button>, makes the button close the dialog with an optional result from the bound value.\nFor example:\n\n<h2 mat-dialog-title>Delete all elements?</h2>\n<mat-dialog-content>This will delete all elements that are currently on this page and cannot be undone.</mat-dialog-content>\n<mat-dialog-actions>\n  <button mat-button mat-dialog-close>Cancel</button>\n  <!-- The mat-dialog-close directive optionally accepts a value as a result for the dialog. -->\n  <button mat-button [mat-dialog-close]="true">Delete</button>\n</mat-dialog-actions>\nOnce a dialog opens, the dialog will automatically focus the first tabbable element.\n\nYou can control which elements are tab stops with the tabindex attribute\n\n<button mat-button tabindex="-1">Not Tabbable</button>\nDialog with header, scrollable content and actions\n Controlling the dialog animation\nYou can control the duration of the dialog\'s enter and exit animations using the enterAnimationDuration and exitAnimationDuration options. If you want to disable the dialog\'s animation completely, you can do so by setting the properties to 0ms.\n\n Accessibility\nMatDialog creates modal dialogs that implements the ARIA role="dialog" pattern by default. You can change the dialog\'s role to alertdialog via MatDialogConfig.\n\nYou should provide an accessible label to this root dialog element by setting the ariaLabel or ariaLabelledBy properties of MatDialogConfig. You can additionally specify a description element ID via the ariaDescribedBy property of MatDialogConfig.\n\n Keyboard interaction\nBy default, the escape key closes MatDialog. While you can disable this behavior via the disableClose property of MatDialogConfig, doing this breaks the expected interaction pattern for the ARIA role="dialog" pattern.\n\n Focus management\nWhen opened, MatDialog traps browser focus such that it cannot escape the root role="dialog" element. By default, the first tabbable element in the dialog receives focus. You can customize which element receives focus with the autoFocus property of MatDialogConfig, which supports the following values.\n\nValue\tBehavior\nfirst-tabbable\tFocus the first tabbable element. This is the default setting.\nfirst-header\tFocus the first header element (role="heading", h1 through h6)\ndialog\tFocus the root role="dialog" element.\nAny CSS selector\tFocus the first element matching the given selector.\nWhile the default setting applies the best behavior for most applications, special cases may benefit from these alternatives. Always test your application to verify the behavior that works best for your users.\n\n Focus restoration\nWhen closed, MatDialog restores focus to the element that previously held focus when the dialog opened. However, if that previously focused element no longer exists, you must add additional handling to return focus to an element that makes sense for the user\'s workflow. Opening a dialog from a menu is one common pattern that causes this situation. The menu closes upon clicking an item, thus the focused menu item is no longer in the DOM when the bottom sheet attempts to restore focus.\n\nYou can add handling for this situation with the afterClosed() observable from MatDialogRef.\n\nconst dialogRef = this.dialog.open(DialogFromMenuExampleDialog, {restoreFocus: false});\n\n// Manually restore focus to the menu trigger since the element that\n// opens the dialog won\'t be in the DOM any more when the dialog closes.\ndialogRef.afterClosed().subscribe(() => this.menuTrigger.focus());'}, 'divider': {'Basic divider': {'HTML.html': '<mat-list>\n  <mat-list-item>Item 1</mat-list-item>\n  <mat-divider></mat-divider>\n  <mat-list-item>Item 2</mat-list-item>\n  <mat-divider></mat-divider>\n  <mat-list-item>Item 3</mat-list-item>\n</mat-list>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatDividerModule} from '@angular/material/divider';\nimport {MatListModule} from '@angular/material/list';\n\n/**\n * @title Basic divider\n */\n@Component({\n  selector: 'divider-overview-example',\n  templateUrl: 'divider-overview-example.html',\n  standalone: true,\n  imports: [MatListModule, MatDividerModule],\n})\nexport class DividerOverviewExample {}"}, 'overview.txt': '<mat-divider> is a component that allows for Material styling of a line separator with various orientation options.\n\n Simple divider\nA <mat-divider> element can be used on its own to create a horizontal or vertical line styled with a Material theme\n\n<mat-divider></mat-divider>\n Inset divider\nAdd the inset attribute in order to set whether or not the divider is an inset divider.\n\n<mat-divider [inset]="true"></mat-divider>\n Vertical divider\nAdd the vertical attribute in order to set whether or not the divider is vertically-oriented.\n\n<mat-divider [vertical]="true"></mat-divider>\n Lists with inset dividers\nDividers can be added to lists as a means of separating content into distinct sections. Inset dividers can also be added to provide the appearance of distinct elements in a list without cluttering content like avatar images or icons. Make sure to avoid adding an inset divider to the last element in a list, because it will overlap with the section divider.\n\n<mat-list>\n   <h3 mat-subheader>Folders</h3>\n   @for (folder of folders; track folder) {\n      <mat-list-item>\n         <mat-icon mat-list-icon>folder</mat-icon>\n         <h4 mat-line>{{folder.name}}</h4>\n         <p mat-line class="demo-2">{{folder.updated}}</p>\n         @if (!$last) {\n            <mat-divider [inset]="true"></mat-divider>\n         }\n      </mat-list-item>\n   }\n   <mat-divider></mat-divider>\n   <h3 mat-subheader>Notes</h3>\n   @for (note of notes; track node) {\n      <mat-list-item>\n         <mat-icon mat-list-icon>note</mat-icon>\n         <h4 mat-line>{{note.name}}</h4>\n         <p mat-line class="demo-2"> {{note.updated}} </p>\n      </mat-list-item>\n   }\n</mat-list>\n Accessibility\nMatDivider applies the ARIA role="separator" attribute, exclusively implementing the non-focusable style of separator that distinguishes sections of content.'}, 'expansion': {'Accordion with expandcollapse all toggles': {'CSS.css': '.example-action-buttons {\n  padding-bottom: 20px;\n}\n\n.example-headers-align .mat-expansion-panel-header-description {\n  justify-content: space-between;\n  align-items: center;\n}\n\n.example-headers-align .mat-mdc-form-field + .mat-mdc-form-field {\n  margin-left: 8px;\n}', 'HTML.html': '<div class="example-action-buttons">\n  <button mat-button (click)="accordion.openAll()">Expand All</button>\n  <button mat-button (click)="accordion.closeAll()">Collapse All</button>\n</div>\n<mat-accordion class="example-headers-align" multi>\n  <mat-expansion-panel>\n    <mat-expansion-panel-header>\n      <mat-panel-title>\n        Personal data\n      </mat-panel-title>\n      <mat-panel-description>\n        Type your name and age\n        <mat-icon>account_circle</mat-icon>\n      </mat-panel-description>\n    </mat-expansion-panel-header>\n\n    <mat-form-field>\n      <mat-label>First name</mat-label>\n      <input matInput>\n    </mat-form-field>\n\n    <mat-form-field>\n      <mat-label>Age</mat-label>\n      <input matInput type="number" min="1">\n    </mat-form-field>\n\n  </mat-expansion-panel>\n  <mat-expansion-panel disabled>\n    <mat-expansion-panel-header>\n      <mat-panel-title>\n        Destination\n      </mat-panel-title>\n      <mat-panel-description>\n        Type the country name\n        <mat-icon>map</mat-icon>\n      </mat-panel-description>\n    </mat-expansion-panel-header>\n\n    <mat-form-field>\n      <mat-label>Country</mat-label>\n      <input matInput>\n    </mat-form-field>\n  </mat-expansion-panel>\n\n  <mat-expansion-panel>\n    <mat-expansion-panel-header>\n      <mat-panel-title>\n        Day of the trip\n      </mat-panel-title>\n      <mat-panel-description>\n        Inform the date you wish to travel\n        <mat-icon>date_range</mat-icon>\n      </mat-panel-description>\n    </mat-expansion-panel-header>\n\n    <mat-form-field>\n      <mat-label>Date</mat-label>\n      <input matInput [matDatepicker]="picker" (focus)="picker.open()" readonly>\n    </mat-form-field>\n    <mat-datepicker #picker></mat-datepicker>\n  </mat-expansion-panel>\n</mat-accordion>', 'TS.ts': "import {Component, ViewChild} from '@angular/core';\nimport {MatAccordion, MatExpansionModule} from '@angular/material/expansion';\nimport {MatDatepickerModule} from '@angular/material/datepicker';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatIconModule} from '@angular/material/icon';\nimport {MatButtonModule} from '@angular/material/button';\nimport {provideNativeDateAdapter} from '@angular/material/core';\n\n/**\n * @title Accordion with expand/collapse all toggles\n */\n@Component({\n  selector: 'expansion-expand-collapse-all-example',\n  templateUrl: 'expansion-expand-collapse-all-example.html',\n  styleUrl: 'expansion-expand-collapse-all-example.css',\n  standalone: true,\n  providers: [provideNativeDateAdapter()],\n  imports: [\n    MatButtonModule,\n    MatExpansionModule,\n    MatIconModule,\n    MatFormFieldModule,\n    MatInputModule,\n    MatDatepickerModule,\n  ],\n})\nexport class ExpansionExpandCollapseAllExample {\n  @ViewChild(MatAccordion) accordion: MatAccordion;\n}"}, 'Basic expansion panel': {'HTML.html': '<mat-accordion>\n  <mat-expansion-panel hideToggle>\n    <mat-expansion-panel-header>\n      <mat-panel-title>\n        This is the expansion title\n      </mat-panel-title>\n      <mat-panel-description>\n        This is a summary of the content\n      </mat-panel-description>\n    </mat-expansion-panel-header>\n    <p>This is the primary content of the panel.</p>\n  </mat-expansion-panel>\n  <mat-expansion-panel (opened)="panelOpenState = true"\n                       (closed)="panelOpenState = false">\n    <mat-expansion-panel-header>\n      <mat-panel-title>\n        Self aware panel\n      </mat-panel-title>\n      <mat-panel-description>\n        Currently I am {{panelOpenState ? \'open\' : \'closed\'}}\n      </mat-panel-description>\n    </mat-expansion-panel-header>\n    <p>I\'m visible because I am open</p>\n  </mat-expansion-panel>\n</mat-accordion>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatExpansionModule} from '@angular/material/expansion';\n\n/**\n * @title Basic expansion panel\n */\n@Component({\n  selector: 'expansion-overview-example',\n  templateUrl: 'expansion-overview-example.html',\n  standalone: true,\n  imports: [MatExpansionModule],\n})\nexport class ExpansionOverviewExample {\n  panelOpenState = false;\n}"}, 'overview.txt': '<mat-expansion-panel> provides an expandable details-summary view.\n\n Expansion-panel content\n Header\nThe <mat-expansion-panel-header> shows a summary of the panel content and acts as the control for expanding and collapsing. This header may optionally contain an <mat-panel-title> and an <mat-panel-description>, which format the content of the header to align with Material Design specifications.\n\n<mat-expansion-panel hideToggle>\n  <mat-expansion-panel-header>\n    <mat-panel-title>\n      This is the expansion title\n    </mat-panel-title>\n    <mat-panel-description>\n      This is a summary of the content\n    </mat-panel-description>\n  </mat-expansion-panel-header>\n  <p>This is the primary content of the panel.</p>\n</mat-expansion-panel>\nBy default, the expansion-panel header includes a toggle icon at the end of the header to indicate the expansion state. This icon can be hidden via the hideToggle property.\n\n<mat-expansion-panel hideToggle>\n\n Action bar\nActions may optionally be included at the bottom of the panel, visible only when the expansion is in its expanded state.\n<mat-action-row>\n  <button mat-button color="primary" (click)="nextStep()">Next</button>\n</mat-action-row>\n\n Disabling a panel\nExpansion panels can be disabled using the disabled attribute. A disabled expansion panel can\'t be toggled by the user, but can still be manipulated programmatically.\n<mat-expansion-panel disabled>\n\n Accordion\nMultiple expansion-panels can be combined into an accordion. The multi="true" input allows the expansions state to be set independently of each other. When multi="false" (default) just one panel can be expanded at a given time:\n<mat-accordion class="example-headers-align" multi>\n\n Lazy rendering\nBy default, the expansion panel content will be initialized even when the panel is closed. To instead defer initialization until the panel is open, the content should be provided as an ng-template:\n<mat-expansion-panel>\n  <mat-expansion-panel-header>\n    This is the expansion title\n  </mat-expansion-panel-header>\n\n  <ng-template matExpansionPanelContent>\n    Some deferred content\n  </ng-template>\n</mat-expansion-panel>\n\n Accessibility\nMatExpansionPanel imitates the experience of the native <details> and <summary> elements. The expansion panel header applies role="button" and the aria-controls attribute with the content element\'s ID.\nBecause expansion panel headers are buttons, avoid adding interactive controls as children of <mat-expansion-panel-header>, including buttons and anchors.'}, 'form-field': {'Form field appearance variants': {'HTML.html': '<p>\n  <mat-form-field appearance="fill">\n    <mat-label>Fill form field</mat-label>\n    <input matInput placeholder="Placeholder">\n    <mat-icon matSuffix>sentiment_very_satisfied</mat-icon>\n    <mat-hint>Hint</mat-hint>\n  </mat-form-field>\n</p>\n<p>\n  <mat-form-field appearance="outline">\n    <mat-label>Outline form field</mat-label>\n    <input matInput placeholder="Placeholder">\n    <mat-icon matSuffix>sentiment_very_satisfied</mat-icon>\n    <mat-hint>Hint</mat-hint>\n  </mat-form-field>\n</p>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatIconModule} from '@angular/material/icon';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\n/** @title Form field appearance variants */\n@Component({\n  selector: 'form-field-appearance-example',\n  templateUrl: 'form-field-appearance-example.html',\n  standalone: true,\n  imports: [MatFormFieldModule, MatInputModule, MatIconModule],\n})\nexport class FormFieldAppearanceExample {}"}, 'Form field with error messages': {'CSS.css': '.example-container mat-form-field + mat-form-field {\n  margin-left: 8px;\n}', 'HTML.html': '<div class="example-container">\n  <mat-form-field>\n    <mat-label>Enter your email</mat-label>\n    <input matInput\n           placeholder="pat@example.com"\n           [formControl]="email"\n           (blur)="updateErrorMessage()"\n           required>\n    @if (email.invalid) {\n      <mat-error>{{errorMessage}}</mat-error>\n    }\n  </mat-form-field>\n</div>', 'TS.ts': "import {Component} from '@angular/core';\nimport {takeUntilDestroyed} from '@angular/core/rxjs-interop';\nimport {FormControl, Validators, FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {merge} from 'rxjs';\n\n/** @title Form field with error messages */\n@Component({\n  selector: 'form-field-error-example',\n  templateUrl: 'form-field-error-example.html',\n  styleUrl: 'form-field-error-example.css',\n  standalone: true,\n  imports: [MatFormFieldModule, MatInputModule, FormsModule, ReactiveFormsModule],\n})\nexport class FormFieldErrorExample {\n  email = new FormControl('', [Validators.required, Validators.email]);\n\n  errorMessage = '';\n\n  constructor() {\n    merge(this.email.statusChanges, this.email.valueChanges)\n      .pipe(takeUntilDestroyed())\n      .subscribe(() => this.updateErrorMessage());\n  }\n\n  updateErrorMessage() {\n    if (this.email.hasError('required')) {\n      this.errorMessage = 'You must enter a value';\n    } else if (this.email.hasError('email')) {\n      this.errorMessage = 'Not a valid email';\n    } else {\n      this.errorMessage = '';\n    }\n  }\n}"}, 'Form field with hints': {'CSS.css': '.example-container mat-form-field + mat-form-field {\n  margin-left: 8px;\n}', 'HTML.html': '<div class="example-container">\n  <mat-form-field hintLabel="Max 10 characters">\n    <mat-label>Enter some input</mat-label>\n    <input matInput #input maxlength="10" placeholder="Ex. Nougat">\n    <mat-hint align="end">{{input.value.length}}/10</mat-hint>\n  </mat-form-field>\n\n  <mat-form-field>\n    <mat-label>Select me</mat-label>\n    <mat-select>\n      <mat-option value="option">Option</mat-option>\n    </mat-select>\n    <mat-hint align="end">Here\'s the dropdown arrow ^</mat-hint>\n  </mat-form-field>\n</div>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatSelectModule} from '@angular/material/select';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\n/** @title Form field with hints */\n@Component({\n  selector: 'form-field-hint-example',\n  templateUrl: 'form-field-hint-example.html',\n  styleUrl: 'form-field-hint-example.css',\n  standalone: true,\n  imports: [MatFormFieldModule, MatInputModule, MatSelectModule],\n})\nexport class FormFieldHintExample {}"}, 'Simple form field': {'CSS.css': ':host {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n}', 'HTML.html': '<mat-form-field>\n  <mat-label>Input</mat-label>\n  <input matInput>\n</mat-form-field>\n<mat-form-field>\n  <mat-label>Select</mat-label>\n  <mat-select>\n    <mat-option value="one">First option</mat-option>\n    <mat-option value="two">Second option</mat-option>\n  </mat-select>\n</mat-form-field>\n<mat-form-field>\n  <mat-label>Textarea</mat-label>\n  <textarea matInput></textarea>\n</mat-form-field>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatSelectModule} from '@angular/material/select';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\n/** @title Simple form field */\n@Component({\n  selector: 'form-field-overview-example',\n  templateUrl: 'form-field-overview-example.html',\n  styleUrl: 'form-field-overview-example.css',\n  standalone: true,\n  imports: [MatFormFieldModule, MatInputModule, MatSelectModule],\n})\nexport class FormFieldOverviewExample {}"}, 'overview.txt': '<mat-form-field> is a component used to wrap several Angular Material components and apply common Text field styles such as the underline, floating label, and hint messages.\n\nIn this document, "form field" refers to the wrapper component <mat-form-field> and "form field control" refers to the component that the <mat-form-field> is wrapping (e.g. the input, textarea, select, etc.)\n\nThe following Angular Material components are designed to work inside a <mat-form-field>:\n\n<input matNativeControl> & <textarea matNativeControl>\n<select matNativeControl>\n<mat-select>\n<mat-chip-list>\n\nForm field appearance variants\nmat-form-field supports two different appearance variants which can be set via the appearance input: fill and outline. The fill appearance displays the form field with a filled background box and an underline, while the outline appearance shows the form field with a border all the way around.\n\nOut of the box, if you do not specify an appearance for the <mat-form-field> it will default to fill. However, this can be configured using a global provider to choose a different default appearance for your app.\n\n@NgModule({\n  providers: [\n    {provide: MAT_FORM_FIELD_DEFAULT_OPTIONS, useValue: {appearance: \'outline\'}}\n  ]\n})\n\nFloating label\nThe floating label is a text label displayed on top of the form field control when the control does not contain any text or when <select matNativeControl> does not show any option text. By default, when text is present the floating label floats above the form field control. The label for a form field can be specified by adding a mat-label element.\nIf the form field control is marked with a required attribute, an asterisk will be appended to the label to indicate the fact that it is a required field. If unwanted, this can be disabled by setting the hideRequiredMarker property on <mat-form-field>\nThe floatLabel property of <mat-form-field> can be used to change this default floating behavior. It can be set to always to float the label even when no text is present in the form field control, or to auto to restore the default behavior.\n\nThe floating label behavior can be adjusted globally by providing a value for MAT_FORM_FIELD_DEFAULT_OPTIONS in your application\'s root module. Like the floatLabel input, the option can be either set to always or auto.\n\n@NgModule({\n  providers: [\n    {provide: MAT_FORM_FIELD_DEFAULT_OPTIONS, useValue: {floatLabel: \'always\'}}\n  ]\n})\n\nHint labels\nHint labels are additional descriptive text that appears below the form field\'s underline. A <mat-form-field> can have up to two hint labels; one start-aligned (left in an LTR language, right in RTL), and one end-aligned.\nHint labels are specified in one of two ways: either by using the hintLabel property of <mat-form-field>, or by adding a <mat-hint> element inside the form field. When adding a hint via the hintLabel property, it will be treated as the start hint. Hints added via the <mat-hint> hint element can be added to either side by setting the align property on <mat-hint> to either start or end. Attempting to add multiple hints to the same side will raise an error.\n\nError messages\nError messages can be shown under the form field underline by adding mat-error elements inside the form field. Errors are hidden initially and will be displayed on invalid form fields after the user has interacted with the element or the parent form has been submitted. Since the errors occupy the same space as the hints, the hints are hidden when the errors are shown.\nIf a form field can have more than one error state, it is up to the consumer to toggle which messages should be displayed. This can be done with CSS, @if or @switch. Multiple error messages can be shown at the same time if desired, but the <mat-form-field> only reserves enough space to display one error message at a time. Ensuring that enough space is available to display multiple errors is up to the user.\n\nPrefix & suffix\nCustom content can be included before and after the input tag, as a prefix or suffix. It will be included within the visual container that wraps the form control as per the Material specification.\nAdding the matPrefix directive to an element inside the <mat-form-field> will designate it as the prefix. Similarly, adding matSuffix will designate it as the suffix.\nIf the prefix/suffix content is purely text-based, it is recommended to use the matTextPrefix or matTextSuffix directives which ensure that the text is aligned with the form control.\n\nCustom form field controls\nIn addition to the form field controls that Angular Material provides, it is possible to create custom form field controls that work with <mat-form-field> in the same way. For additional information on this see the guide on Creating Custom mat-form-field Controls.\n\n Theming\n<mat-form-field> has a color property which can be set to primary, accent, or warn. This will set the color of the form field underline and floating label based on the theme colors of your app.\n\nAccessibility\nBy itself, MatFormField does not apply any additional accessibility treatment to a control. However, several of the form field\'s optional features interact with the control contained within the form field.\nWhen you provide a label via <mat-label>, MatFormField automatically associates this label with the field\'s control via a native <label> element, using the for attribute to reference the control\'s ID.\nIf a floating label is specified, it will be automatically used as the label for the form field control. If no floating label is specified, the user should label the form field control themselves using aria-label, aria-labelledby or <label for=...>.\nWhen you provide informational text via <mat-hint> or <mat-error>, MatFormField automatically adds these elements\' IDs to the control\'s aria-describedby attribute. Additionally, MatError applies aria-live="polite" by default such that assistive technology will announce errors when they appear.\n\nTroubleshooting\n Error: A hint was already declared for align="..."\nThis error occurs if you have added multiple hints for the same side. Keep in mind that the hintLabel property adds a hint to the start side.\n\n Error: mat-form-field must contain a MatFormFieldControl\nThis error occurs when you have not added a form field control to your form field. If your form field contains a native <input> or <textarea> element, make sure you\'ve added the matInput directive to it and have imported MatInputModule. Other components that can act as a form field control include <mat-select>, <mat-chip-list>, and any custom form field controls you\'ve created.'}, 'icon': {'Basic icons': {'HTML.html': '<mat-icon aria-hidden="false" aria-label="Example home icon" fontIcon="home"></mat-icon>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatIconModule} from '@angular/material/icon';\n\n/**\n * @title Basic icons\n */\n@Component({\n  selector: 'icon-overview-example',\n  templateUrl: 'icon-overview-example.html',\n  standalone: true,\n  imports: [MatIconModule],\n})\nexport class IconOverviewExample {}"}, 'overview.txt': 'mat-icon makes it easier to use vector-based icons in your app. This directive supports both icon fonts and SVG icons, but not bitmap-based formats (png, jpg, etc.).\n\nRegistering icons\nMatIconRegistry is an injectable service that allows you to associate icon names with SVG URLs, HTML strings and to define aliases for CSS font classes. Its methods are discussed below and listed in the API summary.\n\n Font icons with ligatures\nSome fonts are designed to show icons by using ligatures, for example by rendering the text "home" as a home image. To use a ligature icon, put its text in the content of the mat-icon component.\n\nBy default, <mat-icon> expects the Material icons font. (You will still need to include the HTML to load the font and its CSS, as described in the link).\n\nYou can specify a different font, such as Material\'s latest icons, Material Symbols, by setting the fontSet input to either the CSS class to apply to use the desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias. Alternatively you can set the default for all your application\'s icons using MatIconRegistry.setDefaultFontSetClass.\n\n Font icons with CSS\nFonts can also display icons by defining a CSS class for each icon glyph, which typically uses a :before selector to cause the icon to appear. Font Awesome uses this approach to display its icons. To use such a font, set the fontSet input to the font\'s CSS class (either the class itself or an alias registered with MatIconRegistry.registerFontClassAlias), and set the fontIcon input to the class for the specific icon to show.\n\nFor both types of font icons, you can specify the default font class to use when fontSet is not explicitly set by calling MatIconRegistry.setDefaultFontSetClass.\n\n SVG icons\n<mat-icon> displays SVG icons by directly inlining the SVG content into the DOM as a child of itself. This approach offers an advantage over an <img> tag or a CSS background-image because it allows styling the SVG with CSS. For example, the default color of the SVG content is the CSS currentColor value. This makes SVG icons by default have the same color as surrounding text, and allows you to change the color by setting the color style on the mat-icon element.\n\nIn order to guard against XSS vulnerabilities, any SVG URLs and HTML strings passed to the MatIconRegistry must be marked as trusted by using Angular\'s DomSanitizer service.\n\nMatIconRegistry fetches all remote SVG icons via Angular\'s HttpClient service. If you haven\'t included HttpClientModule from the @angular/common/http package in your NgModule imports, you will get an error at runtime.\n\nNote that HttpClient fetches SVG icons registered with a URL via XmlHttpRequest, subject to the Same-origin policy. This means that icon URLs must have the same origin as the containing page or that the application\'s server must be configured to allow cross-origin requests.\n\n Named icons\nTo associate a name with an icon URL, use the addSvgIcon, addSvgIconInNamespace, addSvgIconLiteral or addSvgIconLiteralInNamespace methods of MatIconRegistry. After registering an icon, it can be displayed by setting the svgIcon input. For an icon in the default namespace, use the name directly. For a non-default namespace, use the format [namespace]:[name].\n\n Icon sets\nIcon sets allow grouping multiple icons into a single SVG file. This is done by creating a single root <svg> tag that contains multiple nested <svg> tags in its <defs> section. Each of these nested tags is identified with an id attribute. This id is used as the name of the icon.\n\nIcon sets are registered using the addSvgIconSet, addSvgIconSetInNamespace, addSvgIconSetLiteral or addSvgIconSetLiteralInNamespace methods of MatIconRegistry. After an icon set is registered, each of its embedded icons can be accessed by their id attributes. To display an icon from an icon set, use the svgIcon input in the same way as for individually registered icons.\n\nMultiple icon sets can be registered in the same namespace. Requesting an icon whose id appears in more than one icon set, the icon from the most recently registered set will be used.\n\n Theming\nBy default, icons will use the current font color (currentColor). this color can be changed to match the current theme\'s colors using the color attribute. This can be changed to \'primary\', \'accent\', or \'warn\'.\n\n Accessibility\nSimilar to an <img> element, an icon alone does not convey any useful information for a screen-reader user. The user of <mat-icon> must provide additional information pertaining to how the icon is used. Based on the use-cases described below, mat-icon is marked as aria-hidden="true" by default, but this can be overridden by adding aria-hidden="false" to the element.\n\nIn thinking about accessibility, it is useful to place icon use into one of three categories:\n\nDecorative: the icon conveys no real semantic meaning and is purely cosmetic.\nInteractive: a user will click or otherwise interact with the icon to perform some action.\nIndicator: the icon is not interactive, but it conveys some information, such as a status. This includes using the icon in place of text inside of a larger message.\n Decorative icons\nWhen the icon is purely cosmetic and conveys no real semantic meaning, the <mat-icon> element is marked with aria-hidden="true".\n\n Interactive icons\nIcons alone are not interactive elements for screen-reader users; when the user would interact with some icon on the page, a more appropriate element should "own" the interaction:\n\nThe <mat-icon> element should be a child of a <button> or <a> element.\nThe parent <button> or <a> should either have a meaningful label provided either through direct text content, aria-label, or aria-labelledby.\n Indicator icons\nWhen the presence of an icon communicates some information to the user whether as an indicator or by being inlined into a block of text, that information must also be made available to screen-readers. The most straightforward way to do this is to\n\nAdd a <span> as an adjacent sibling to the <mat-icon> element with text that conveys the same information as the icon.\nAdd the cdk-visually-hidden class to the <span>. This will make the message invisible on-screen but still available to screen-reader users.\n Bidirectionality\nBy default icons in an RTL layout will look exactly the same as in LTR, however certain icons have to be mirrored for RTL users. If you want to mirror an icon only in an RTL layout, you can use the mat-icon-rtl-mirror CSS class.\n\n<mat-icon class="mat-icon-rtl-mirror" svgIcon="thumb-up"></mat-icon>'}, 'input': {'Basic Inputs': {'CSS.css': '.example-form {\n  min-width: 150px;\n  max-width: 500px;\n  width: 100%;\n}\n\n.example-full-width {\n  width: 100%;\n}', 'HTML.html': '<form class="example-form">\n  <mat-form-field class="example-full-width">\n    <mat-label>Favorite food</mat-label>\n    <input matInput placeholder="Ex. Pizza" value="Sushi" />\n  </mat-form-field>\n\n  <mat-form-field class="example-full-width">\n    <mat-label>Leave a comment</mat-label>\n    <textarea matInput placeholder="Ex. It makes me feel..."></textarea>\n  </mat-form-field>\n</form>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {FormsModule} from '@angular/forms';\n\n/**\n * @title Basic Inputs\n */\n@Component({\n  selector: 'input-overview-example',\n  styleUrl: 'input-overview-example.css',\n  templateUrl: 'input-overview-example.html',\n  standalone: true,\n  imports: [FormsModule, MatFormFieldModule, MatInputModule],\n})\nexport class InputOverviewExample {}"}, 'overview.txt': 'matInput is a directive that allows native <input> and <textarea> elements to work with <mat-form-field>.\n\n<input> and <textarea> attributes\nAll of the attributes that can be used with <input> and <textarea> elements can be used on elements inside <mat-form-field> as well. This includes Angular directives such as ngModel and formControl.\n\nThe only limitation is that the type attribute can only be one of the values supported by matNativeControl.\n\n Supported <input> types\nThe following input types can be used with matNativeControl:\n\ncolor\ndate\ndatetime-local\nemail\nmonth\nnumber\npassword\nsearch\ntel\ntext\ntime\nurl\nweek\n Form field features\nThere are a number of <mat-form-field> features that can be used with any <input matNativeControl> or <textarea matNativeControl>. These include error messages, hint text, prefix & suffix, and theming. For additional information about these features, see the form field documentation.\n\n Placeholder\nThe placeholder is text shown when the <mat-form-field> label is floating but the input is empty. It is used to give the user an additional hint about what they should type in the input. The placeholder can be specified by setting the placeholder attribute on the <input> or <textarea> element. In some cases that <mat-form-field> may use the placeholder as the label (see the form field label documentation).\n\n Changing when error messages are shown\nThe <mat-form-field> allows you to associate error messages with your matNativeControl. By default, these error messages are shown when the control is invalid and the user has interacted with (touched) the element or the parent form has been submitted. If you wish to override this behavior (e.g. to show the error as soon as the invalid control is dirty or when a parent form group is invalid), you can use the errorStateMatcher property of the matNativeControl. The property takes an instance of an ErrorStateMatcher object. An ErrorStateMatcher must implement a single method isErrorState which takes the FormControl for this matNativeControl as well as the parent form and returns a boolean indicating whether errors should be shown. (true indicating that they should be shown, and false indicating that they should not.)\n\nA global error state matcher can be specified by setting the ErrorStateMatcher provider. This applies to all inputs. For convenience, ShowOnDirtyErrorStateMatcher is available in order to globally cause input errors to show when the input is dirty and invalid.\n\n@NgModule({\n  providers: [\n    {provide: ErrorStateMatcher, useClass: ShowOnDirtyErrorStateMatcher}\n  ]\n})\n Auto-resizing <textarea> elements\n<textarea> elements can be made to automatically resize by using the cdkTextareaAutosize directive available in the CDK.\n\n Responding to changes in the autofill state of an <input>\nThe CDK provides utilities for detecting when an input becomes autofilled and changing the appearance of the autofilled state.\n\n Accessibility\nThe matNativeControl directive works with native <input> to provide an accessible experience.\n\n Aria attributes\nIf the containing <mat-form-field> has a label it will automatically be used as the aria-label for the <input>. However, if there\'s no label specified in the form field, aria-label, aria-labelledby or <label for=...> should be added.\n\n Errors and hints\nAny mat-error and mat-hint are automatically added to the input\'s aria-describedby list, and aria-invalid is automatically updated based on the input\'s validity state.\n\nWhen conveying an error, be sure to not rely solely on color. In the message itself, you can use an icon or text such as "Error:" to indicate the message is an error message.\n\n Troubleshooting\n Error: Input type "..." isn\'t supported by matInput\nThis error is thrown when you attempt to set an input\'s type property to a value that isn\'t supported by the matInput directive. If you need to use an unsupported input type with <mat-form-field> consider writing a custom form field control for it.'}, 'list': {'Basic list': {'HTML.html': '<mat-list role="list">\n  <mat-list-item role="listitem">Item 1</mat-list-item>\n  <mat-list-item role="listitem">Item 2</mat-list-item>\n  <mat-list-item role="listitem">Item 3</mat-list-item>\n</mat-list>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatListModule} from '@angular/material/list';\n\n/**\n * @title Basic list\n */\n@Component({\n  selector: 'list-overview-example',\n  templateUrl: 'list-overview-example.html',\n  standalone: true,\n  imports: [MatListModule],\n})\nexport class ListOverviewExample {}"}, 'List with single selection': {'HTML.html': '<mat-selection-list #shoes [multiple]="false">\n  @for (shoe of typesOfShoes; track shoe) {\n    <mat-list-option [value]="shoe">{{shoe}}</mat-list-option>\n  }\n</mat-selection-list>\n\n<p>\n  Option selected: {{shoes.selectedOptions.hasValue() ? shoes.selectedOptions.selected[0].value : \'None\'}}\n</p>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatListModule} from '@angular/material/list';\n\n/**\n * @title List with single selection\n */\n@Component({\n  selector: 'list-single-selection-example',\n  templateUrl: 'list-single-selection-example.html',\n  standalone: true,\n  imports: [MatListModule],\n})\nexport class ListSingleSelectionExample {\n  typesOfShoes: string[] = ['Boots', 'Clogs', 'Loafers', 'Moccasins', 'Sneakers'];\n}"}, 'overview.txt': '<mat-list> is a container component that wraps and formats a series of <mat-list-item>. As the base list component, it provides Material Design styling, but no behavior of its own.\n\nList items can be constructed in two ways depending the content they need to show:\n\n Simple lists\nIf a list item needs to show a single line of textual information, the text can be inserted directly into the <mat-list-item> element.\n\n<mat-list>\n <mat-list-item>Pepper</mat-list-item>\n <mat-list-item>Salt</mat-list-item>\n <mat-list-item>Paprika</mat-list-item>\n</mat-list>\n Multi-line lists\nList items that have more than one line of text have to use the matListItemTitle directive to indicate their title text for accessibility purposes, in addition to the matListItemLine directive for each subsequent line of text.\n\n<mat-list>\n  <mat-list-item>\n    <span matListItemTitle>Pepper</span>\n    <span matListItemLine>Produced by a plant</span>\n  </mat-list-item>\n  <mat-list-item>\n    <span matListItemTitle>Salt</span>\n    <span matListItemLine>Extracted from sea water</span>\n  </mat-list-item>\n  <mat-list-item>\n    <span matListItemTitle>Paprika</span>\n    <span matListItemLine>Produced by dried and ground red peppers</span>\n  </mat-list-item>\n</mat-list>\nTo activate text wrapping, the lines input has to be set on the <mat-list-item> indicating the number of lines of text.\n\nThe following directives can be used to style the content of a list item:\n\nDirective\tDescription\nmatListItemTitle\tIndicates the title of the list item. Required for multi-line list items.\nmatListItemLine\tWraps a line of text within a list item.\nmatListItemIcon\tIcon typically placed at the beginning of a list item.\nmatListItemAvatar\tImage typically placed at the beginning of a list item.\nmatListItemMeta\tInserts content in the meta section at the end of a list item.\n Navigation lists\nUse mat-nav-list tags for navigation lists (i.e. lists that have anchor tags).\n\nSimple navigation lists can use the mat-list-item attribute on anchor tag elements directly:\n\n<mat-nav-list>\n  @for (link of list; track link) {\n    <a mat-list-item href="..." [activated]="link.isActive">{{ link }}</a>\n  }\n</mat-nav-list>\nFor more complex navigation lists (e.g. with more than one target per item), wrap the anchor element in an <mat-list-item>.\n\n<mat-nav-list>\n  @for (link of links; track link) {\n    <mat-list-item [activated]="link.isActive">\n       <a matListItemTitle href="...">{{ link }}</a>\n       <button mat-icon-button (click)="showInfo(link)" matListItemMeta>\n          <mat-icon>info</mat-icon>\n       </button>\n    </mat-list-item>\n  }\n</mat-nav-list>\n Action lists\nUse the <mat-action-list> element when each item in the list performs some action. Each item in an action list is a <button> element.\n\nSimple action lists can use the mat-list-item attribute on button tag elements directly:\n\n<mat-action-list>\n  <button mat-list-item (click)="save()">Save</button>\n  <button mat-list-item (click)="undo()">Undo</button>\n</mat-action-list>\n Selection lists\nA selection list provides an interface for selecting values, where each list item is an option.\n\nThe options within a selection-list should not contain further interactive controls, such as buttons and anchors.\n\n Multi-line lists\nFor lists that require multiple lines per item, annotate each line with an matListItemLine attribute. Whichever heading tag is appropriate for your DOM hierarchy should be used (not necessarily <h3> as shown in the example).\n\n<!-- two line list -->\n<mat-list>\n  @for (message of messages; track message) {\n    <mat-list-item>\n      <h3 matListItemTitle>{{message.from}}</h3>\n      <p matListItemLine>\n        <span>{{message.subject}}</span>\n        <span class="demo-2"> -- {{message.content}}</span>\n      </p>\n    </mat-list-item>\n  }\n</mat-list>\n\n<!-- three line list -->\n<mat-list>\n  @for (message of messages; track message) {\n    <mat-list-item>\n      <h3 matListItemTitle>{{message.from}}</h3>\n      <p matListItemLine>{{message.subject}}</p>\n      <p matListItemLine class="demo-2">{{message.content}}</p>\n    </mat-list-item>\n  }\n</mat-list>\n Lists with icons\nTo add an icon to your list item, use the matListItemIcon attribute.\n\n<mat-list>\n  @for (message of messages; track message) {\n    <mat-list-item>\n      <mat-icon matListItemIcon>folder</mat-icon>\n      <h3 matListItemTitle>{{message.from}}</h3>\n      <p matListItemLine>\n        <span>{{message.subject}}</span>\n        <span class="demo-2"> -- {{message.content}}</span>\n      </p>\n    </mat-list-item>\n  }\n</mat-list>\n Lists with avatars\nTo include an avatar image, add an image tag with an matListItemAvatar attribute.\n\n<mat-list>\n  @for (message of messages; track message) {\n    <mat-list-item>\n      <img matListItemAvatar src="..." alt="...">\n      <h3 matListItemTitle>{{message.from}}</h3>\n      <p matListItemLine>\n        <span>{{message.subject}}</span>\n        <span class="demo-2"> -- {{message.content}}</span>\n      </p>\n    </mat-list-item>\n  }\n</mat-list>\n Lists with multiple sections\nSubheaders can be added to a list by annotating a heading tag with an matSubheader attribute. To add a divider, use <mat-divider>.\n\n<mat-list>\n   <h3 matSubheader>Folders</h3>\n   @for (folder of folders; track folder) {\n     <mat-list-item>\n        <mat-icon matListIcon>folder</mat-icon>\n        <h4 matListItemTitle>{{folder.name}}</h4>\n        <p matListItemLine class="demo-2"> {{folder.updated}} </p>\n     </mat-list-item>\n   }\n   <mat-divider></mat-divider>\n   <h3 matSubheader>Notes</h3>\n   @for (note of notes; track note) {\n     <mat-list-item>\n        <mat-icon matListIcon>note</mat-icon>\n        <h4 matListItemTitle>{{note.name}}</h4>\n        <p matListItemLine class="demo-2"> {{note.updated}} </p>\n     </mat-list-item>\n   }\n</mat-list>\n Accessibility\nAngular Material offers multiple varieties of list so that you can choose the type that best applies to your use-case.\n\n Navigation\nYou should use MatNavList when every item in the list is an anchor that navigate to another URL. The root <mat-nav-list> element sets role="navigation" and should contain only anchor elements with the mat-list-item attribute. You should not nest any interactive elements inside these anchors, including buttons and checkboxes.\nAlways provide an accessible label for the <mat-nav-list> element via aria-label or aria-labelledby.\n\n Selection\nYou should use MatSelectionList and MatListOption for lists that allow the user to select one or more values. This list variant uses the role="listbox" interaction pattern, handling all associated keyboard input and focus management. You should not nest any interactive elements inside these options, including buttons and anchors.\nAlways provide an accessible label for the <mat-selection-list> element via aria-label or aria-labelledby that describes the selection being made.\nBy default, MatSelectionList displays radio or checkmark indicators to identify selected items. While you can hide the radio indicator for single-selection via hideSingleSelectionIndicator, this makes the component less accessible by making it harder or impossible for users to visually identify selected items.\n\n Custom scenarios\nBy default, the list assumes that it will be used in a purely decorative fashion and thus it sets no roles, ARIA attributes, or keyboard shortcuts. This is equivalent to having a sequence of <div> elements on the page. Any interactive content within the list should be given an appropriate accessibility treatment based on the specific workflow of your application.\nIf the list is used to present a list of non-interactive content items, then the list element should be given role="list" and each list item should be given role="listitem".'}, 'menu': {'Menu positioning': {'HTML.html': '<button mat-button [matMenuTriggerFor]="aboveMenu">Above</button>\n<mat-menu #aboveMenu="matMenu" yPosition="above">\n  <button mat-menu-item>Item 1</button>\n  <button mat-menu-item>Item 2</button>\n</mat-menu>\n\n<button mat-button [matMenuTriggerFor]="belowMenu">Below</button>\n<mat-menu #belowMenu="matMenu" yPosition="below">\n  <button mat-menu-item>Item 1</button>\n  <button mat-menu-item>Item 2</button>\n</mat-menu>\n\n<button mat-button [matMenuTriggerFor]="beforeMenu">Before</button>\n<mat-menu #beforeMenu="matMenu" xPosition="before">\n  <button mat-menu-item>Item 1</button>\n  <button mat-menu-item>Item 2</button>\n</mat-menu>\n\n\n<button mat-button [matMenuTriggerFor]="afterMenu">After</button>\n<mat-menu #afterMenu="matMenu" xPosition="after">\n  <button mat-menu-item>Item 1</button>\n  <button mat-menu-item>Item 2</button>\n</mat-menu>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatMenuModule} from '@angular/material/menu';\nimport {MatButtonModule} from '@angular/material/button';\n\n/**\n * @title Menu positioning\n */\n@Component({\n  selector: 'menu-position-example',\n  templateUrl: 'menu-position-example.html',\n  standalone: true,\n  imports: [MatButtonModule, MatMenuModule],\n})\nexport class MenuPositionExample {}"}, 'Menu with icons': {'HTML.html': '<button mat-icon-button [matMenuTriggerFor]="menu" aria-label="Example icon-button with a menu">\n  <mat-icon>more_vert</mat-icon>\n</button>\n<mat-menu #menu="matMenu">\n  <button mat-menu-item>\n    <mat-icon>dialpad</mat-icon>\n    <span>Redial</span>\n  </button>\n  <button mat-menu-item disabled>\n    <mat-icon>voicemail</mat-icon>\n    <span>Check voice mail</span>\n  </button>\n  <button mat-menu-item>\n    <mat-icon>notifications_off</mat-icon>\n    <span>Disable alerts</span>\n  </button>\n</mat-menu>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatIconModule} from '@angular/material/icon';\nimport {MatMenuModule} from '@angular/material/menu';\nimport {MatButtonModule} from '@angular/material/button';\n\n/**\n * @title Menu with icons\n */\n@Component({\n  selector: 'menu-icons-example',\n  templateUrl: 'menu-icons-example.html',\n  standalone: true,\n  imports: [MatButtonModule, MatMenuModule, MatIconModule],\n})\nexport class MenuIconsExample {}"}, 'overview.txt': '<mat-menu> is a floating panel containing list of options.\n\nBy itself, the <mat-menu> element does not render anything. The menu is attached to and opened via application of the matMenuTriggerFor directive:\n\n<button mat-button [matMenuTriggerFor]="menu">Menu</button>\n Toggling the menu programmatically\nThe menu exposes an API to open/close programmatically. Please note that in this case, an matMenuTriggerFor directive is still necessary to attach the menu to a trigger element in the DOM.\n\nclass MyComponent {\n  @ViewChild(MatMenuTrigger) trigger: MatMenuTrigger;\n\n  someMethod() {\n    this.trigger.openMenu();\n  }\n}\n Icons\nMenus support displaying mat-icon elements before the menu item text.\n\n<button mat-icon-button [matMenuTriggerFor]="menu" aria-label="Example icon-button with a menu">\n  <mat-icon>more_vert</mat-icon>\n</button>\n<mat-menu #menu="matMenu">\n  <button mat-menu-item>\n    <mat-icon>dialpad</mat-icon>\n    <span>Redial</span>\n  </button>\n  <button mat-menu-item disabled>\n    <mat-icon>voicemail</mat-icon>\n    <span>Check voice mail</span>\n  </button>\n  <button mat-menu-item>\n    <mat-icon>notifications_off</mat-icon>\n    <span>Disable alerts</span>\n  </button>\n</mat-menu>\n Customizing menu position\nBy default, the menu will display below (y-axis), after (x-axis), without overlapping its trigger. The position can be changed using the xPosition (before | after) and yPosition (above | below) attributes. The menu can be forced to overlap the trigger using the overlapTrigger attribute.\n\n<mat-menu #aboveMenu="matMenu" yPosition="above">\n Nested menu\nMaterial supports the ability for an mat-menu-item to open a sub-menu. To do so, you have to define your root menu and sub-menus, in addition to setting the [matMenuTriggerFor] on the mat-menu-item that should trigger the sub-menu:\n\n<mat-menu #animals="matMenu">\n  <button mat-menu-item [matMenuTriggerFor]="vertebrates">Vertebrates</button>\n  <button mat-menu-item [matMenuTriggerFor]="invertebrates">Invertebrates</button>\n</mat-menu>\n\n<mat-menu #vertebrates="matMenu">\n  <button mat-menu-item [matMenuTriggerFor]="fish">Fishes</button>\n  <button mat-menu-item [matMenuTriggerFor]="amphibians">Amphibians</button>\n  <button mat-menu-item [matMenuTriggerFor]="reptiles">Reptiles</button>\n  <button mat-menu-item>Birds</button>\n  <button mat-menu-item>Mammals</button>\n</mat-menu>\n Lazy rendering\nBy default, the menu content will be initialized even when the panel is closed. To defer initialization until the menu is open, the content can be provided as an ng-template with the matMenuContent attribute:\n\n<mat-menu #appMenu="matMenu">\n  <ng-template matMenuContent>\n    <button mat-menu-item>Settings</button>\n    <button mat-menu-item>Help</button>\n  </ng-template>\n</mat-menu>\n\n<button mat-icon-button [matMenuTriggerFor]="appMenu">\n  <mat-icon>more_vert</mat-icon>\n</button>\n Passing in data to a menu\nWhen using lazy rendering, additional context data can be passed to the menu panel via the matMenuTriggerData input. This allows for a single menu instance to be rendered with a different set of data, depending on the trigger that opened it:\n\n<mat-menu #appMenu="matMenu">\n  <ng-template matMenuContent let-name="name">\n    <button mat-menu-item>Settings</button>\n    <button mat-menu-item>Log off {{name}}</button>\n  </ng-template>\n</mat-menu>\n\n<button mat-icon-button [matMenuTriggerFor]="appMenu" [matMenuTriggerData]="{name: \'Sally\'}">\n  <mat-icon>more_vert</mat-icon>\n</button>\n\n<button mat-icon-button [matMenuTriggerFor]="appMenu" [matMenuTriggerData]="{name: \'Bob\'}">\n  <mat-icon>more_vert</mat-icon>\n</button>\n\nAccessibility\nAngular Material\'s menu component consists of two connected parts: the trigger and the pop-up menu.\nThe menu trigger is a standard button element augmented with aria-haspopup, aria-expanded, and aria-controls to create the relationship to the pop-up panel.\nThe pop-up menu implements the role="menu" pattern, handling keyboard interaction and focus management. Upon opening, the trigger will focus the first focusable menu item. Upon close, the menu will return focus to its trigger. Avoid creating a menu in which all items are disabled, instead hiding or disabling the menu trigger.\nAngular Material does not support the menuitemcheckbox or menuitemradio roles.\nAlways provide an accessible label via aria-label or aria-labelledby for any menu triggers or menu items without descriptive text content.\nMatMenu should not contain any interactive controls aside from MatMenuItem.'}, 'radio': {'Basic radios': {'CSS.css': '.mat-mdc-radio-button ~ .mat-mdc-radio-button {\n  margin-left: 16px;\n}', 'HTML.html': '<mat-radio-group aria-label="Select an option">\n  <mat-radio-button value="1">Option 1</mat-radio-button>\n  <mat-radio-button value="2">Option 2</mat-radio-button>\n</mat-radio-group>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatRadioModule} from '@angular/material/radio';\n\n/**\n * @title Basic radios\n */\n@Component({\n  selector: 'radio-overview-example',\n  templateUrl: 'radio-overview-example.html',\n  styleUrl: 'radio-overview-example.css',\n  standalone: true,\n  imports: [MatRadioModule],\n})\nexport class RadioOverviewExample {}"}, 'Radios with ngModel': {'CSS.css': '.example-radio-group {\n  display: flex;\n  flex-direction: column;\n  margin: 15px 0;\n  align-items: flex-start;\n}\n\n.example-radio-button {\n  margin: 5px;\n}', 'HTML.html': '<label id="example-radio-group-label">Pick your favorite season</label>\n<mat-radio-group\n  aria-labelledby="example-radio-group-label"\n  class="example-radio-group"\n  [(ngModel)]="favoriteSeason">\n  @for (season of seasons; track season) {\n    <mat-radio-button class="example-radio-button" [value]="season">{{season}}</mat-radio-button>\n  }\n</mat-radio-group>\n<div>Your favorite season is: {{favoriteSeason}}</div>', 'TS.ts': "import {Component} from '@angular/core';\nimport {FormsModule} from '@angular/forms';\nimport {MatRadioModule} from '@angular/material/radio';\n\n/**\n * @title Radios with ngModel\n */\n@Component({\n  selector: 'radio-ng-model-example',\n  templateUrl: 'radio-ng-model-example.html',\n  styleUrl: 'radio-ng-model-example.css',\n  standalone: true,\n  imports: [MatRadioModule, FormsModule],\n})\nexport class RadioNgModelExample {\n  favoriteSeason: string;\n  seasons: string[] = ['Winter', 'Spring', 'Summer', 'Autumn'];\n}"}, 'overview.txt': '<mat-radio-button> provides the same functionality as a native <input type="radio"> enhanced with Material Design styling and animations.\n\nAll radio-buttons with the same name comprise a set from which only one may be selected at a time.\n\n Radio-button label\nThe radio-button label is provided as the content to the <mat-radio-button> element. The label can be positioned before or after the radio-button by setting the labelPosition property to \'before\' or \'after\'.\n\nIf you don\'t want the label to appear next to the radio-button, you can use aria-label or aria-labelledby to specify an appropriate label.\n\n Radio groups\nRadio-buttons should typically be placed inside of an <mat-radio-group> unless the DOM structure would make that impossible (e.g., radio-buttons inside of table cells). The radio-group has a value property that reflects the currently selected radio-button inside of the group.\n\nIndividual radio-buttons inside of a radio-group will inherit the name of the group.\n\n Use with @angular/forms\n<mat-radio-group> is compatible with @angular/forms and supports both FormsModule and ReactiveFormsModule.\n\n Default Color Configuration\nThe default color for radio buttons can be configured globally using the MAT_RADIO_DEFAULT_OPTIONS provider\n\nproviders: [{\n    provide: MAT_RADIO_DEFAULT_OPTIONS,\n    useValue: { color: \'accent\' },\n}]\n Accessibility\nMatRadioButton uses an internal <input type="radio"> to provide an accessible experience. This internal radio button receives focus and is automatically labelled by the text content of the <mat-radio-button> element. Avoid adding other interactive controls into the content of <mat-radio-button>, as this degrades the experience for users of assistive technology.\nAlways provide an accessible label via aria-label or aria-labelledby for radio buttons without descriptive text content. For dynamic labels and descriptions, MatRadioButton provides input properties for binding aria-label, aria-labelledby, and aria-describedby. This means that you should not use the attr. prefix when binding these properties, as demonstrated below.\n<mat-radio-button [aria-label]="getMultipleChoiceAnswer()">\n</mat-radio-button>\nPrefer placing all radio buttons inside of a <mat-radio-group> rather than creating standalone radio buttons because groups are easier to use exclusively with a keyboard.\nYou should provide an accessible label for all <mat-radio-group> elements via aria-label or aria-labelledby.'}, 'select': {'Basic select': {'HTML.html': '<h4>Basic mat-select</h4>\n<mat-form-field>\n  <mat-label>Favorite food</mat-label>\n  <mat-select>\n    @for (food of foods; track food) {\n      <mat-option [value]="food.value">{{food.viewValue}}</mat-option>\n    }\n  </mat-select>\n</mat-form-field>\n\n<h4>Basic native select</h4>\n<mat-form-field>\n  <mat-label>Cars</mat-label>\n  <select matNativeControl required>\n    <option value="volvo">Volvo</option>\n    <option value="saab">Saab</option>\n    <option value="mercedes">Mercedes</option>\n    <option value="audi">Audi</option>\n  </select>\n</mat-form-field>', 'TS.ts': "import {Component} from '@angular/core';\nimport {FormsModule} from '@angular/forms';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatSelectModule} from '@angular/material/select';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\ninterface Food {\n  value: string;\n  viewValue: string;\n}\n\n/**\n * @title Basic select\n */\n@Component({\n  selector: 'select-overview-example',\n  templateUrl: 'select-overview-example.html',\n  standalone: true,\n  imports: [MatFormFieldModule, MatSelectModule, MatInputModule, FormsModule],\n})\nexport class SelectOverviewExample {\n  foods: Food[] = [\n    {value: 'steak-0', viewValue: 'Steak'},\n    {value: 'pizza-1', viewValue: 'Pizza'},\n    {value: 'tacos-2', viewValue: 'Tacos'},\n  ];\n}"}, 'Select in a form': {'HTML.html': '<form>\n  <h4>mat-select</h4>\n  <mat-form-field>\n    <mat-label>Favorite food</mat-label>\n    <mat-select [(ngModel)]="selectedValue" name="food">\n      @for (food of foods; track food) {\n        <mat-option [value]="food.value">{{food.viewValue}}</mat-option>\n      }\n    </mat-select>\n  </mat-form-field>\n  <p> Selected food: {{selectedValue}} </p>\n  <h4>native html select</h4>\n  <mat-form-field>\n    <mat-label>Favorite car</mat-label>\n    <select matNativeControl [(ngModel)]="selectedCar" name="car">\n      <option value="" selected></option>\n      @for (car of cars; track car) {\n        <option [value]="car.value">{{car.viewValue}}</option>\n      }\n    </select>\n  </mat-form-field>\n  <p> Selected car: {{selectedCar}} </p>\n</form>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatSelectModule} from '@angular/material/select';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {FormsModule} from '@angular/forms';\n\ninterface Food {\n  value: string;\n  viewValue: string;\n}\n\ninterface Car {\n  value: string;\n  viewValue: string;\n}\n\n/**\n * @title Select in a form\n */\n@Component({\n  selector: 'select-form-example',\n  templateUrl: 'select-form-example.html',\n  standalone: true,\n  imports: [FormsModule, MatFormFieldModule, MatSelectModule, MatInputModule],\n})\nexport class SelectFormExample {\n  selectedValue: string;\n  selectedCar: string;\n\n  foods: Food[] = [\n    {value: 'steak-0', viewValue: 'Steak'},\n    {value: 'pizza-1', viewValue: 'Pizza'},\n    {value: 'tacos-2', viewValue: 'Tacos'},\n  ];\n\n  cars: Car[] = [\n    {value: 'volvo', viewValue: 'Volvo'},\n    {value: 'saab', viewValue: 'Saab'},\n    {value: 'mercedes', viewValue: 'Mercedes'},\n  ];\n}"}, 'Select in a reactive form': {'HTML.html': '<form [formGroup]="form">\n  <h4>mat-select</h4>\n  <mat-form-field>\n    <mat-label>Favorite Food</mat-label>\n    <mat-select [formControl]="foodControl" name="food">\n      <mat-option>None</mat-option>\n      @for (food of foods; track food) {\n        <mat-option [value]="food.value">{{food.viewValue}}</mat-option>\n      }\n    </mat-select>\n  </mat-form-field>\n  <p>Selected: {{foodControl.value}}</p>\n  <h4>Native select</h4>\n  <mat-form-field>\n    <mat-label>Favorite Car</mat-label>\n    <select matNativeControl [formControl]="carControl" name="car">\n      <option value="">None</option>\n      @for (car of cars; track car) {\n        <option [value]="car.value">{{car.viewValue}}</option>\n      }\n    </select>\n  </mat-form-field>\n  <p>Selected: {{carControl.value}}</p>\n</form>', 'TS.ts': "import {Component} from '@angular/core';\nimport {FormControl, FormGroup, FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatSelectModule} from '@angular/material/select';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\ninterface Food {\n  value: string;\n  viewValue: string;\n}\n\ninterface Car {\n  value: string;\n  viewValue: string;\n}\n\n/**\n * @title Select in a reactive form\n */\n@Component({\n  selector: 'select-reactive-form-example',\n  templateUrl: 'select-reactive-form-example.html',\n  standalone: true,\n  imports: [FormsModule, ReactiveFormsModule, MatFormFieldModule, MatSelectModule, MatInputModule],\n})\nexport class SelectReactiveFormExample {\n  foods: Food[] = [\n    {value: 'steak-0', viewValue: 'Steak'},\n    {value: 'pizza-1', viewValue: 'Pizza'},\n    {value: 'tacos-2', viewValue: 'Tacos'},\n  ];\n  cars: Car[] = [\n    {value: 'volvo', viewValue: 'Volvo'},\n    {value: 'saab', viewValue: 'Saab'},\n    {value: 'mercedes', viewValue: 'Mercedes'},\n  ];\n  foodControl = new FormControl(this.foods[2].value);\n  carControl = new FormControl(this.cars[1].value);\n  form = new FormGroup({\n    food: this.foodControl,\n    car: this.carControl,\n  });\n}"}, 'overview.txt': '<mat-select> is a form control for selecting a value from a set of options, similar to the native <select> element. You can read more about selects in the Material Design spec. It is designed to work inside of a <mat-form-field> element.\nTo add options to the select, add <mat-option> elements to the <mat-select>. Each <mat-option> has a value property that can be used to set the value that will be selected if the user chooses this option. The content of the <mat-option> is what will be shown to the user.\nAngular Material also supports use of the native <select> element inside of <mat-form-field>. The native control has several performance, accessibility, and usability advantages. See the documentation for form-field for more information.\nTo use a native select inside <mat-form-field>, import MatInputModule and add the matNativeControl attribute to the <select> element.\n\nGetting and setting the select value\nThe <mat-select> supports 2-way binding to the value property without the need for Angular forms.\n\nBoth<mat-select> and <select> support all of the form directives from the core FormsModule (NgModel) and ReactiveFormsModule (FormControl, FormGroup, etc.) As with native <select>, <mat-select> also supports a compareWith function. (Additional information about using a custom compareWith function can be found in the Angular forms documentation).\n\nForm field features\nThere are a number of <mat-form-field> features that can be used with both <select> and <mat-select>. These include error messages, hint text, prefix & suffix, and theming. For additional information about these features, see the form field documentation.\n\nSetting a static placeholder\nThe placeholder is text shown when the <mat-form-field> label is floating but the <mat-select> is empty. It is used to give the user an additional hint about the value they should select. The placeholder can be specified by setting the placeholder attribute on the <mat-select> element. In some cases that <mat-form-field> may use the placeholder as the label (see the form field label documentation).\n\n Disabling the select or individual options\nIt is possible to disable the entire select or individual options in the select by using the disabled property on the <select> or <mat-select> and the <option> or <mat-option> elements respectively. When working with Reactive Forms, the select component can be disabled/enabled via form controls. This can be accomplished by creating a FormControl with the disabled property FormControl({value: \'\', disabled: true}) or using FormControl.enable(), FormControl.disable().\n\nResetting the select value\nIf you want one of your options to reset the select\'s value, you can omit specifying its value.\n\nUsing multiple selection with a native select element (<select multiple>) is discouraged inside <mat-form-field>, as the inline listbox appearance is inconsistent with other Material Design components.\n\nAccessibility\nWhen possible, prefer a native <select> element over MatSelect. The native control provides the most accessible experience across the widest range of platforms.\nMatSelect implements the combobox pattern detailed in the 1.2 version of the ARIA specification. The combobox trigger controls a role="listbox" element opened in a pop-up. Previous versions of the ARIA specification required that role="combobox" apply to a text input control, but the 1.2 version of the specification supports a wider variety of interaction patterns. This newer usage of ARIA works in all browser and screen-reader combinations supported by Angular Material.\nBecause the pop-up uses the role="listbox" pattern, you should not put other interactive controls, such as buttons or checkboxes, inside a select option. Nesting interactive controls like this interferes with most assistive technology.\nAlways provide an accessible label for the select. This can be done by adding a <mat-label> inside of <mat-form-field>, the aria-label attribute, or the aria-labelledby attribute.\nBy default, MatSelect displays a checkmark to identify selected items. While you can hide the checkmark indicator for single-selection via hideSingleSelectionIndicator, this makes the component less accessible by making it harder or impossible for users to visually identify selected items.\n\n Troubleshooting\n Error: Cannot change multiple mode of select after initialization\nThis error is thrown if you attempt to bind the multiple property on <mat-select> to a dynamic value. (e.g. [multiple]="isMultiple" where the value of isMultiple changes over the course of the component\'s lifetime). If you need to change this dynamically, use @if or @switch instead:\n\n@if (isMultiple) {\n  <mat-select multiple>\n    ...\n  </mat-select>\n} @else {\n  <mat-select>\n    ...\n  </mat-select>\n}\n Error: Value must be an array in multiple-selection mode\nThis error is thrown if you attempt to assign a value other than null, undefined, or an array to a <mat-select multiple>. For example, something like mySelect.value = \'option1\'. What you likely meant to do was mySelect.value = [\'option1\'].\n\n Error: compareWith must be a function\nThis error occurs if you attempt to assign something other than a function to the compareWith property. For more information on proper usage of compareWith see the Angular forms documentation).'}, 'sidenav': {'Basic sidenav': {'CSS.css': '.example-container {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background: #eee;\n}', 'HTML.html': '<mat-sidenav-container class="example-container">\n  <mat-sidenav mode="side" opened>Sidenav content</mat-sidenav>\n  <mat-sidenav-content>Main content</mat-sidenav-content>\n</mat-sidenav-container>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatSidenavModule} from '@angular/material/sidenav';\n\n/** @title Basic sidenav */\n@Component({\n  selector: 'sidenav-overview-example',\n  templateUrl: 'sidenav-overview-example.html',\n  styleUrl: 'sidenav-overview-example.css',\n  standalone: true,\n  imports: [MatSidenavModule],\n})\nexport class SidenavOverviewExample {\n}"}, 'overview.txt': 'Angular Material provides two sets of components designed to add collapsible side content (often navigation, though it can be any content) alongside some primary content. These are the sidenav and drawer components.\n\nThe sidenav components are designed to add side content to a fullscreen app. To set up a sidenav we use three components: <mat-sidenav-container> which acts as a structural container for our content and sidenav, <mat-sidenav-content> which represents the main content, and <mat-sidenav> which represents the added side content.\n\nThe drawer component is designed to add side content to a small section of your app. This is accomplished using the <mat-drawer-container>, <mat-drawer-content>, and <mat-drawer> components, which are analogous to their sidenav equivalents. Rather than adding side content to the app as a whole, these are designed to add side content to a small section of your app. They support almost all of the same features, but do not support fixed positioning.\n\nSpecifying the main and side content\nBoth the main and side content should be placed inside of the <mat-sidenav-container>, content that you don\'t want to be affected by the sidenav, such as a header or footer, can be placed outside of the container.\n\nThe side content should be wrapped in a <mat-sidenav> element. The position property can be used to specify which end of the main content to place the side content on. position can be either start or end which places the side content on the left or right respectively in left-to-right languages. If the position is not set, the default value of start will be assumed. A <mat-sidenav-container> can have up to two <mat-sidenav> elements total, but only one for any given side. The <mat-sidenav> must be placed as an immediate child of the <mat-sidenav-container>.\n\nThe main content should be wrapped in a <mat-sidenav-content>. If no <mat-sidenav-content> is specified for a <mat-sidenav-container>, one will be created implicitly and all of the content inside the <mat-sidenav-container> other than the <mat-sidenav> elements will be placed inside of it.\n\nThe following are examples of valid sidenav layouts:\n\n<!-- Creates a layout with a left-positioned sidenav and explicit content. -->\n<mat-sidenav-container>\n  <mat-sidenav>Start</mat-sidenav>\n  <mat-sidenav-content>Main</mat-sidenav-content>\n</mat-sidenav-container>\n<!-- Creates a layout with a left and right sidenav and implicit content. -->\n<mat-sidenav-container>\n  <mat-sidenav>Start</mat-sidenav>\n  <mat-sidenav position="end">End</mat-sidenav>\n  <section>Main</section>\n</mat-sidenav-container>\n<!-- Creates an empty sidenav container with no sidenavs and implicit empty content. -->\n<mat-sidenav-container></mat-sidenav-container>\nAnd these are examples of invalid sidenav layouts:\n\n<!-- Invalid because there are two `start` position sidenavs. -->\n<mat-sidenav-container>\n  <mat-sidenav>Start</mat-sidenav>\n  <mat-sidenav position="start">Start 2</mat-sidenav>\n</mat-sidenav-container>\n<!-- Invalid because there are multiple `<mat-sidenav-content>` elements. -->\n<mat-sidenav-container>\n  <mat-sidenav-content>Main</mat-sidenav-content>\n  <mat-sidenav-content>Main 2</mat-sidenav-content>\n</mat-sidenav-container>\n<!-- Invalid because the `<mat-sidenav>` is outside of the `<mat-sidenav-container>`. -->\n<mat-sidenav-container></mat-sidenav-container>\n<mat-sidenav></mat-sidenav>\nThese same rules all apply to the drawer components as well.\n\n Opening and closing a sidenav\nA <mat-sidenav> can be opened or closed using the open(), close() and toggle() methods. Each of these methods returns a Promise<boolean> that will be resolved with true when the sidenav finishes opening or false when it finishes closing.\n\nThe opened state can also be set via a property binding in the template using the opened property. The property supports 2-way binding.\n\n<mat-sidenav> also supports output properties for just open and just close events, The (opened) and (closed) properties respectively.\nAll of these properties and methods work on <mat-drawer> as well.\n\n Changing the sidenav\'s behavior\nThe <mat-sidenav> can render in one of three different ways based on the mode property.\n\nMode\tDescription\nover\tSidenav floats over the primary content, which is covered by a backdrop\npush\tSidenav pushes the primary content out of its way, also covering it with a backdrop\nside\tSidenav appears side-by-side with the main content, shrinking the main content\'s width to make space for the sidenav.\nIf no mode is specified, over is used by default.\n\nThe over and push sidenav modes show a backdrop by default, while the side mode does not. This can be customized by setting the hasBackdrop property on mat-sidenav-container. Explicitly setting hasBackdrop to true or false will override the default backdrop visibility setting for all sidenavs regardless of mode. Leaving the property unset or setting it to null will use the default backdrop visibility for each mode.\n<mat-drawer> also supports all of these same modes and options.\n\n\nSetting the sidenav\'s size\nThe <mat-sidenav> and <mat-drawer> will, by default, fit the size of its content. The width can be explicitly set via CSS:\n\nmat-sidenav {\n  width: 200px;\n}\nTry to avoid percent based width as resize events are not (yet) supported.\n\n Fixed position sidenavs\nFor <mat-sidenav> only (not <mat-drawer>) fixed positioning is supported. It can be enabled by setting the fixedInViewport property. Additionally, top and bottom space can be set via the fixedTopGap and fixedBottomGap. These properties accept a pixel value amount of space to add at the top or bottom.\n\nReacting to scroll events inside the sidenav container\nTo react to scrolling inside the <mat-sidenav-container>, you can get a hold of the underlying CdkScrollable instance through the MatSidenavContainer.\n\nclass YourComponent implements AfterViewInit {\n  @ViewChild(MatSidenavContainer) sidenavContainer: MatSidenavContainer;\n\n  ngAfterViewInit() {\n    this.sidenavContainer.scrollable.elementScrolled().subscribe(() => /* react to scrolling */);\n  }\n}\n Accessibility\nThe <mat-sidenav> and <mat-sidenav-content> should each be given an appropriate role attribute depending on the context in which they are used.\n\nFor example, a <mat-sidenav> that contains links to other pages might be marked role="navigation", whereas one that contains a table of contents about might be marked as role="directory". If there is no more specific role that describes your sidenav, role="region" is recommended.\n\nSimilarly, the <mat-sidenav-content> should be given a role based on what it contains. If it represents the primary content of the page, it may make sense to mark it role="main". If no more specific role makes sense, role="region" is again a good fallback.\n\n Focus management\nThe sidenav has the ability to capture focus. This behavior is turned on for the push and over modes and it is off for side mode. You can change its default behavior by the autoFocus input.\n\nBy default the first tabbable element will receive focus upon open. If you want a different element to be focused, you can set the cdkFocusInitial attribute on it.\n\n Troubleshooting\n Error: A drawer was already declared for \'position="..."\'\nThis error is thrown if you have more than one sidenav or drawer in a given container with the same position. The position property defaults to start, so the issue may just be that you forgot to mark the end sidenav with position="end".'}, 'slide-toggle': {'Basic slide-toggles': {'HTML.html': '<mat-slide-toggle>Slide me!</mat-slide-toggle>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatSlideToggleModule} from '@angular/material/slide-toggle';\n\n/**\n * @title Basic slide-toggles\n */\n@Component({\n  selector: 'slide-toggle-overview-example',\n  templateUrl: 'slide-toggle-overview-example.html',\n  standalone: true,\n  imports: [MatSlideToggleModule],\n})\nexport class SlideToggleOverviewExample {}"}, 'Slide-toggle with forms': {'CSS.css': '.example-form mat-slide-toggle {\n  margin: 8px 0;\n  display: block;\n}', 'HTML.html': '<p>Slide Toggle using a simple NgModel.</p>\n\n<mat-slide-toggle [(ngModel)]="isChecked">Slide Toggle Checked: {{isChecked}}</mat-slide-toggle>\n\n<p>Slide Toggle inside of a Template-driven form</p>\n\n<form class="example-form" #form="ngForm" (ngSubmit)="alertFormValues(form.form)">\n\n  <mat-slide-toggle ngModel name="enableWifi">Enable Wifi</mat-slide-toggle>\n  <mat-slide-toggle ngModel name="acceptTerms" required>Accept Terms of Service</mat-slide-toggle>\n\n  <button mat-raised-button type="submit">Save Settings</button>\n</form>\n\n<p>Slide Toggle inside of a Reactive form</p>\n\n<form class="example-form" [formGroup]="formGroup" (ngSubmit)="alertFormValues(formGroup)" ngNativeValidate>\n\n  <mat-slide-toggle formControlName="enableWifi">Enable Wifi</mat-slide-toggle>\n  <mat-slide-toggle formControlName="acceptTerms">Accept Terms of Service</mat-slide-toggle>\n\n  <p>Form Group Status: {{formGroup.status}}</p>\n\n  <button mat-raised-button type="submit">Save Settings</button>\n</form>', 'TS.ts': "import {Component} from '@angular/core';\nimport {FormBuilder, FormGroup, Validators, FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {MatButtonModule} from '@angular/material/button';\nimport {\n  MatSlideToggleModule,\n  _MatSlideToggleRequiredValidatorModule,\n} from '@angular/material/slide-toggle';\n\n/**\n * @title Slide-toggle with forms\n */\n@Component({\n  selector: 'slide-toggle-forms-example',\n  templateUrl: './slide-toggle-forms-example.html',\n  styleUrl: './slide-toggle-forms-example.css',\n  standalone: true,\n  imports: [\n    MatSlideToggleModule,\n    FormsModule,\n    _MatSlideToggleRequiredValidatorModule,\n    MatButtonModule,\n    ReactiveFormsModule,\n  ],\n})\nexport class SlideToggleFormsExample {\n  isChecked = true;\n  formGroup = this._formBuilder.group({\n    enableWifi: '',\n    acceptTerms: ['', Validators.requiredTrue],\n  });\n\n  constructor(private _formBuilder: FormBuilder) {}\n\n  alertFormValues(formGroup: FormGroup) {\n    alert(JSON.stringify(formGroup.value, null, 2));\n  }\n}"}, 'overview.txt': '<mat-slide-toggle> is an on/off control that can be toggled via clicking.\n\nThe slide-toggle behaves similarly to a checkbox, though it does not support an indeterminate state like <mat-checkbox>.\n\n Slide-toggle label\nThe slide-toggle label is provided as the content to the <mat-slide-toggle> element.\n\nIf you don\'t want the label to appear next to the slide-toggle, you can use aria-label or aria-labelledby to specify an appropriate label.\n\n Use with @angular/forms\n<mat-slide-toggle> is compatible with @angular/forms and supports both FormsModule and ReactiveFormsModule.\n\n Theming\nThe color of a <mat-slide-toggle> can be changed by using the color property. By default, slide-toggles use the theme\'s accent color. This can be changed to \'primary\' or \'warn\'.\n\n Accessibility\nMatSlideToggle uses an internal <button role="switch"> to provide an accessible experience. This internal button receives focus and is automatically labelled by the text content of the <mat-slide-toggle> element. Avoid adding other interactive controls into the content of <mat-slide-toggle>, as this degrades the experience for users of assistive technology.\n\nAlways provide an accessible label via aria-label or aria-labelledby for toggles without descriptive text content. For dynamic labels, MatSlideToggle provides input properties for binding aria-label and aria-labelledby. This means that you should not use the attr. prefix when binding these properties, as demonstrated below.\n\n<mat-slide-toggle [aria-label]="isSubscribedToEmailsMessage">\n</mat-slide-toggle>'}, 'snack-bar': {'Basic snack-bar': {'CSS.css': 'mat-form-field {\n  margin-right: 12px;\n}', 'HTML.html': '<mat-form-field>\n  <mat-label>Message</mat-label>\n  <input matInput value="Disco party!" #message>\n</mat-form-field>\n\n<mat-form-field>\n  <mat-label>Action</mat-label>\n  <input matInput value="Dance" #action>\n</mat-form-field>\n\n<button mat-stroked-button (click)="openSnackBar(message.value, action.value)">Show snack-bar</button>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatSnackBar} from '@angular/material/snack-bar';\nimport {MatButtonModule} from '@angular/material/button';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\n/**\n * @title Basic snack-bar\n */\n@Component({\n  selector: 'snack-bar-overview-example',\n  templateUrl: 'snack-bar-overview-example.html',\n  styleUrl: 'snack-bar-overview-example.css',\n  standalone: true,\n  imports: [MatFormFieldModule, MatInputModule, MatButtonModule],\n})\nexport class SnackBarOverviewExample {\n  constructor(private _snackBar: MatSnackBar) {}\n\n  openSnackBar(message: string, action: string) {\n    this._snackBar.open(message, action);\n  }\n}"}, 'overview.txt': 'MatSnackBar is a service for displaying snack-bar notifications.\n\nOpening a snackbar\nA snackbar can contain either a string message or a given component.\n\n// Simple message.\nlet snackBarRef = snackBar.open(\'Message archived\');\n\n// Simple message with an action.\nlet snackBarRef = snackBar.open(\'Message archived\', \'Undo\');\n\n// Load the given component into the snackbar.\nlet snackBarRef = snackBar.openFromComponent(MessageArchivedComponent);\nIn either case, a MatSnackBarRef is returned. This can be used to dismiss the snackbar or to receive notification of when the snackbar is dismissed. For simple messages with an action, the MatSnackBarRef exposes an observable for when the action is triggered. If you want to close a custom snackbar that was opened via openFromComponent, from within the component itself, you can inject the MatSnackBarRef.\n\nsnackBarRef.afterDismissed().subscribe(() => {\n  console.log(\'The snackbar was dismissed\');\n});\n\n\nsnackBarRef.onAction().subscribe(() => {\n  console.log(\'The snackbar action was triggered!\');\n});\n\nsnackBarRef.dismiss();\n Dismissal\nA snackbar can be dismissed manually by calling the dismiss method on the MatSnackBarRef returned from the call to open.\n\nOnly one snackbar can ever be opened at one time. If a new snackbar is opened while a previous message is still showing, the older message will be automatically dismissed.\n\nA snackbar can also be given a duration via the optional configuration object:\n\nsnackBar.open(\'Message archived\', \'Undo\', {\n  duration: 3000\n});\n Sharing data with a custom snackbar\nYou can share data with the custom snackbar, that you opened via the openFromComponent method, by passing it through the data property.\n\nsnackBar.openFromComponent(MessageArchivedComponent, {\n  data: \'some data\'\n});\nTo access the data in your component, you have to use the MAT_SNACK_BAR_DATA injection token:\n\nimport {Component, Inject} from \'@angular/core\';\nimport {MAT_SNACK_BAR_DATA} from \'@angular/material/snack-bar\';\n\n@Component({\n  selector: \'your-snackbar\',\n  template: \'passed in {{ data }}\',\n})\nexport class MessageArchivedComponent {\n  constructor(@Inject(MAT_SNACK_BAR_DATA) public data: string) { }\n}\n Annotating custom snackbar content\nWhen opening a custom snackbar via the snackBar.openFromComponent method, you can use the following directives to annotate the content and ensure that it is styled consistently compared to snackbars opened via snackBar.open.\n\nmatSnackBarLabel - Marks the text of the snackbar shown to users\nmatSnackBarActions - Marks the container element containing any action buttons\nmatSnackBarAction - Marks an individual action button\nIf no annotations are used, all the content will be treated as text content.\n\nSetting the global configuration defaults\nIf you want to override the default snack bar options, you can do so using the MAT_SNACK_BAR_DEFAULT_OPTIONS injection token.\n\n@NgModule({\n  providers: [\n    {provide: MAT_SNACK_BAR_DEFAULT_OPTIONS, useValue: {duration: 2500}}\n  ]\n})\n Accessibility\nMatSnackBar announces messages via an aria-live region. While announcements use the polite setting by default, you can customize this by setting the politeness property of MatSnackBarConfig.\n\nMatSnackBar does not move focus to the snackbar element. Moving focus like this would disrupt users in the middle of a workflow. For any action offered in the snackbar, your application should provide an alternative way to perform the action. Alternative interactions are typically keyboard shortcuts or menu options. You should dismiss the snackbar once the user performs its corresponding action. A snackbar can contain a single action with an additional optional "dismiss" or "cancel" action.\n\nAvoid setting a duration for snackbars that have an action available, as screen reader users may want to navigate to the snackbar element to activate the action. If the user has manually moved their focus within the snackbar, you should return focus somewhere that makes sense in the context of the user\'s workflow.'}, 'sort': {'Sorting overview': {'CSS.css': '.mat-sort-header-container {\n  align-items: center;\n}', 'HTML.html': '<table matSort (matSortChange)="sortData($event)">\n  <tr>\n    <th mat-sort-header="name">Dessert (100g)</th>\n    <th mat-sort-header="calories">Calories</th>\n    <th mat-sort-header="fat">Fat (g)</th>\n    <th mat-sort-header="carbs">Carbs (g)</th>\n    <th mat-sort-header="protein">Protein (g)</th>\n  </tr>\n\n  @for (dessert of sortedData; track dessert) {\n    <tr>\n      <td>{{dessert.name}}</td>\n      <td>{{dessert.calories}}</td>\n      <td>{{dessert.fat}}</td>\n      <td>{{dessert.carbs}}</td>\n      <td>{{dessert.protein}}</td>\n    </tr>\n  }\n</table>', 'TS.ts': "import {Component} from '@angular/core';\nimport {Sort, MatSortModule} from '@angular/material/sort';\n\nexport interface Dessert {\n  calories: number;\n  carbs: number;\n  fat: number;\n  name: string;\n  protein: number;\n}\n\n/**\n * @title Sorting overview\n */\n@Component({\n  selector: 'sort-overview-example',\n  templateUrl: 'sort-overview-example.html',\n  styleUrl: 'sort-overview-example.css',\n  standalone: true,\n  imports: [MatSortModule],\n})\nexport class SortOverviewExample {\n  desserts: Dessert[] = [\n    {name: 'Frozen yogurt', calories: 159, fat: 6, carbs: 24, protein: 4},\n    {name: 'Ice cream sandwich', calories: 237, fat: 9, carbs: 37, protein: 4},\n    {name: 'Eclair', calories: 262, fat: 16, carbs: 24, protein: 6},\n    {name: 'Cupcake', calories: 305, fat: 4, carbs: 67, protein: 4},\n    {name: 'Gingerbread', calories: 356, fat: 16, carbs: 49, protein: 4},\n  ];\n\n  sortedData: Dessert[];\n\n  constructor() {\n    this.sortedData = this.desserts.slice();\n  }\n\n  sortData(sort: Sort) {\n    const data = this.desserts.slice();\n    if (!sort.active || sort.direction === '') {\n      this.sortedData = data;\n      return;\n    }\n\n    this.sortedData = data.sort((a, b) => {\n      const isAsc = sort.direction === 'asc';\n      switch (sort.active) {\n        case 'name':\n          return compare(a.name, b.name, isAsc);\n        case 'calories':\n          return compare(a.calories, b.calories, isAsc);\n        case 'fat':\n          return compare(a.fat, b.fat, isAsc);\n        case 'carbs':\n          return compare(a.carbs, b.carbs, isAsc);\n        case 'protein':\n          return compare(a.protein, b.protein, isAsc);\n        default:\n          return 0;\n      }\n    });\n  }\n}\n\nfunction compare(a: number | string, b: number | string, isAsc: boolean) {\n  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n}"}, 'overview.txt': 'The matSort and mat-sort-header are used, respectively, to add sorting state and display to tabular data.\n\nAdding sort to table headers\nTo add sorting behavior and styling to a set of table headers, add the <mat-sort-header> component to each header and provide an id that will identify it. These headers should be contained within a parent element with the matSort directive, which will emit a matSortChange event when the user triggers sorting on the header.\n\nUsers can trigger the sort header through a mouse click or keyboard action. When this happens, the matSort will emit a matSortChange event that contains the ID of the header triggered and the direction to sort (asc or desc).\n\n Changing the sort order\nBy default, a sort header starts its sorting at asc and then desc. Triggering the sort header after desc will remove sorting.\n\nTo reverse the sort order for all headers, set the matSortStart to desc on the matSort directive. To reverse the order only for a specific header, set the start input only on the header instead.\n\nTo prevent the user from clearing the sort state from an already sorted column, set matSortDisableClear to true on the matSort to affect all headers, or set disableClear to true on a specific header.\n\n Disabling sorting\nIf you want to prevent the user from changing the sorting order of any column, you can use the matSortDisabled binding on the mat-sort, or the disabled on a single mat-sort-header.\n\n Using sort with the mat-table\nWhen used on a mat-table header, it is not required to set a mat-sort-header id on because by default it will use the id of the column.\n\nAccessibility\nWhen you apply MatSortHeader to a header cell element, the component wraps the content of the header cell inside a button. The text content of the header cell then becomes the accessible label for the sort button. However, the header cell text typically describes the column and does not indicate that interacting with the control performs a sorting action. To clearly communicate that the header performs sorting, always use the sortActionDescription input to provide a description for the button element, such as "Sort by last name".\nMatSortHeader applies the aria-sort attribute to communicate the active sort state to assistive technology. However, most screen readers do not announce changes to the value of aria-sort, meaning that screen reader users do not receive feedback that sorting occurred. To remedy this, use the matSortChange event on the MatSort directive to announce state updates with the LiveAnnouncer service from @angular/cdk/a11y.\nIf your application contains many tables and sort headers, consider creating a custom directives to consistently apply sortActionDescription and announce sort state changes'}, 'table': {'Basic use of table mat-table': {'CSS.css': 'table {\n  width: 100%;\n}', 'HTML.html': '<table mat-table [dataSource]="dataSource" class="mat-elevation-z8">\n\n  <!--- Note that these columns can be defined in any order.\n        The actual rendered columns are set as a property on the row definition" -->\n\n  <!-- Position Column -->\n  <ng-container matColumnDef="position">\n    <th mat-header-cell *matHeaderCellDef> No. </th>\n    <td mat-cell *matCellDef="let element"> {{element.position}} </td>\n  </ng-container>\n\n  <!-- Name Column -->\n  <ng-container matColumnDef="name">\n    <th mat-header-cell *matHeaderCellDef> Name </th>\n    <td mat-cell *matCellDef="let element"> {{element.name}} </td>\n  </ng-container>\n\n  <!-- Weight Column -->\n  <ng-container matColumnDef="weight">\n    <th mat-header-cell *matHeaderCellDef> Weight </th>\n    <td mat-cell *matCellDef="let element"> {{element.weight}} </td>\n  </ng-container>\n\n  <!-- Symbol Column -->\n  <ng-container matColumnDef="symbol">\n    <th mat-header-cell *matHeaderCellDef> Symbol </th>\n    <td mat-cell *matCellDef="let element"> {{element.symbol}} </td>\n  </ng-container>\n\n  <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>\n  <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>\n</table>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatTableModule} from '@angular/material/table';\n\nexport interface PeriodicElement {\n  name: string;\n  position: number;\n  weight: number;\n  symbol: string;\n}\n\nconst ELEMENT_DATA: PeriodicElement[] = [\n  {position: 1, name: 'Hydrogen', weight: 1.0079, symbol: 'H'},\n  {position: 2, name: 'Helium', weight: 4.0026, symbol: 'He'},\n  {position: 3, name: 'Lithium', weight: 6.941, symbol: 'Li'},\n  {position: 4, name: 'Beryllium', weight: 9.0122, symbol: 'Be'},\n  {position: 5, name: 'Boron', weight: 10.811, symbol: 'B'},\n  {position: 6, name: 'Carbon', weight: 12.0107, symbol: 'C'},\n  {position: 7, name: 'Nitrogen', weight: 14.0067, symbol: 'N'},\n  {position: 8, name: 'Oxygen', weight: 15.9994, symbol: 'O'},\n  {position: 9, name: 'Fluorine', weight: 18.9984, symbol: 'F'},\n  {position: 10, name: 'Neon', weight: 20.1797, symbol: 'Ne'},\n];\n\n/**\n * @title Basic use of `<table mat-table>`\n */\n@Component({\n  selector: 'table-basic-example',\n  styleUrl: 'table-basic-example.css',\n  templateUrl: 'table-basic-example.html',\n  standalone: true,\n  imports: [MatTableModule],\n})\nexport class TableBasicExample {\n  displayedColumns: string[] = ['position', 'name', 'weight', 'symbol'];\n  dataSource = ELEMENT_DATA;\n}"}, 'Table with expandable rows': {'CSS.css': 'table {\n  width: 100%;\n}\n\ntr.example-detail-row {\n  height: 0;\n}\n\ntr.example-element-row:not(.example-expanded-row):hover {\n  background: whitesmoke;\n}\n\ntr.example-element-row:not(.example-expanded-row):active {\n  background: #efefef;\n}\n\n.example-element-row td {\n  border-bottom-width: 0;\n}\n\n.example-element-detail {\n  overflow: hidden;\n  display: flex;\n}\n\n.example-element-diagram {\n  min-width: 80px;\n  border: 2px solid black;\n  padding: 8px;\n  font-weight: lighter;\n  margin: 8px 0;\n  height: 104px;\n}\n\n.example-element-symbol {\n  font-weight: bold;\n  font-size: 40px;\n  line-height: normal;\n}\n\n.example-element-description {\n  padding: 16px;\n}\n\n.example-element-description-attribution {\n  opacity: 0.5;\n}', 'HTML.html': '<table mat-table\n       [dataSource]="dataSource" multiTemplateDataRows\n       class="mat-elevation-z8">\n  @for (column of columnsToDisplay; track column) {\n    <ng-container matColumnDef="{{column}}">\n      <th mat-header-cell *matHeaderCellDef> {{column}} </th>\n      <td mat-cell *matCellDef="let element"> {{element[column]}} </td>\n    </ng-container>\n  }\n  <ng-container matColumnDef="expand">\n    <th mat-header-cell *matHeaderCellDef aria-label="row actions">&nbsp;</th>\n    <td mat-cell *matCellDef="let element">\n      <button mat-icon-button aria-label="expand row" (click)="(expandedElement = expandedElement === element ? null : element); $event.stopPropagation()">\n        @if (expandedElement === element) {\n          <mat-icon>keyboard_arrow_up</mat-icon>\n        } @else {\n          <mat-icon>keyboard_arrow_down</mat-icon>\n        }\n      </button>\n    </td>\n  </ng-container>\n\n  <!-- Expanded Content Column - The detail row is made up of this one column that spans across all columns -->\n  <ng-container matColumnDef="expandedDetail">\n    <td mat-cell *matCellDef="let element" [attr.colspan]="columnsToDisplayWithExpand.length">\n      <div class="example-element-detail"\n           [@detailExpand]="element == expandedElement ? \'expanded\' : \'collapsed\'">\n        <div class="example-element-diagram">\n          <div class="example-element-position"> {{element.position}} </div>\n          <div class="example-element-symbol"> {{element.symbol}} </div>\n          <div class="example-element-name"> {{element.name}} </div>\n          <div class="example-element-weight"> {{element.weight}} </div>\n        </div>\n        <div class="example-element-description">\n          {{element.description}}\n          <span class="example-element-description-attribution"> -- Wikipedia </span>\n        </div>\n      </div>\n    </td>\n  </ng-container>\n\n  <tr mat-header-row *matHeaderRowDef="columnsToDisplayWithExpand"></tr>\n  <tr mat-row *matRowDef="let element; columns: columnsToDisplayWithExpand;"\n      class="example-element-row"\n      [class.example-expanded-row]="expandedElement === element"\n      (click)="expandedElement = expandedElement === element ? null : element">\n  </tr>\n  <tr mat-row *matRowDef="let row; columns: [\'expandedDetail\']" class="example-detail-row"></tr>\n</table>', 'TS.ts': "import {Component} from '@angular/core';\nimport {animate, state, style, transition, trigger} from '@angular/animations';\nimport {MatIconModule} from '@angular/material/icon';\nimport {MatButtonModule} from '@angular/material/button';\nimport {MatTableModule} from '@angular/material/table';\n\n/**\n * @title Table with expandable rows\n */\n@Component({\n  selector: 'table-expandable-rows-example',\n  styleUrl: 'table-expandable-rows-example.css',\n  templateUrl: 'table-expandable-rows-example.html',\n  animations: [\n    trigger('detailExpand', [\n      state('collapsed,void', style({height: '0px', minHeight: '0'})),\n      state('expanded', style({height: '*'})),\n      transition('expanded <=> collapsed', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),\n    ]),\n  ],\n  standalone: true,\n  imports: [MatTableModule, MatButtonModule, MatIconModule],\n})\nexport class TableExpandableRowsExample {\n  dataSource = ELEMENT_DATA;\n  columnsToDisplay = ['name', 'weight', 'symbol', 'position'];\n  columnsToDisplayWithExpand = [...this.columnsToDisplay, 'expand'];\n  expandedElement: PeriodicElement | null;\n}\n\nexport interface PeriodicElement {\n  name: string;\n  position: number;\n  weight: number;\n  symbol: string;\n  description: string;\n}\n\nconst ELEMENT_DATA: PeriodicElement[] = [\n  {\n    position: 1,\n    name: 'Hydrogen',\n    weight: 1.0079,\n    symbol: 'H',\n    description: `Hydrogen is a chemical element with symbol H and atomic number 1.`,\n  },\n  {\n    position: 2,\n    name: 'Helium',\n    weight: 4.0026,\n    symbol: 'He',\n    description: `Helium is a chemical element with symbol He and atomic number 2.`,\n  },\n  {\n    position: 3,\n    name: 'Lithium',\n    weight: 6.941,\n    symbol: 'Li',\n    description: `Lithium is a chemical element with symbol Li and atomic number 3.`,\n  },\n  {\n    position: 4,\n    name: 'Beryllium',\n    weight: 9.0122,\n    symbol: 'Be',\n    description: `Beryllium is a chemical element with symbol Be and atomic number 4.`,\n  },\n  {\n    position: 5,\n    name: 'Boron',\n    weight: 10.811,\n    symbol: 'B',\n    description: `Boron is a chemical element with symbol B and atomic number 5.`,\n  },\n  {\n    position: 6,\n    name: 'Carbon',\n    weight: 12.0107,\n    symbol: 'C',\n    description: `Carbon is a chemical element with symbol C and atomic number 6.`,\n  },\n  {\n    position: 7,\n    name: 'Nitrogen',\n    weight: 14.0067,\n    symbol: 'N',\n    description: `Nitrogen is a chemical element with symbol N and atomic number 7.`,\n  },\n  {\n    position: 8,\n    name: 'Oxygen',\n    weight: 15.9994,\n    symbol: 'O',\n    description: `Oxygen is a chemical element with symbol O and atomic number 8.`,\n  },\n  {\n    position: 9,\n    name: 'Fluorine',\n    weight: 18.9984,\n    symbol: 'F',\n    description: `Fluorine is a chemical element with symbol F and atomic number 9.`,\n  },\n  {\n    position: 10,\n    name: 'Neon',\n    weight: 20.1797,\n    symbol: 'Ne',\n    description: `Neon is a chemical element with symbol Ne and atomic number 10.`,\n  },\n];"}, 'Table with filtering': {'CSS.css': '/* Structure */\ntable {\n  width: 100%;\n}\n\n.mat-mdc-form-field {\n  font-size: 14px;\n  width: 100%;\n}', 'HTML.html': '<mat-form-field>\n  <mat-label>Filter</mat-label>\n  <input matInput (keyup)="applyFilter($event)" placeholder="Ex. ium" #input>\n</mat-form-field>\n\n<table mat-table [dataSource]="dataSource" class="mat-elevation-z8">\n\n  <!-- Position Column -->\n  <ng-container matColumnDef="position">\n    <th mat-header-cell *matHeaderCellDef> No. </th>\n    <td mat-cell *matCellDef="let element"> {{element.position}} </td>\n  </ng-container>\n\n  <!-- Name Column -->\n  <ng-container matColumnDef="name">\n    <th mat-header-cell *matHeaderCellDef> Name </th>\n    <td mat-cell *matCellDef="let element"> {{element.name}} </td>\n  </ng-container>\n\n  <!-- Weight Column -->\n  <ng-container matColumnDef="weight">\n    <th mat-header-cell *matHeaderCellDef> Weight </th>\n    <td mat-cell *matCellDef="let element"> {{element.weight}} </td>\n  </ng-container>\n\n  <!-- Symbol Column -->\n  <ng-container matColumnDef="symbol">\n    <th mat-header-cell *matHeaderCellDef> Symbol </th>\n    <td mat-cell *matCellDef="let element"> {{element.symbol}} </td>\n  </ng-container>\n\n  <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>\n  <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>\n\n  <!-- Row shown when there is no matching data. -->\n  <tr class="mat-row" *matNoDataRow>\n    <td class="mat-cell" colspan="4">No data matching the filter "{{input.value}}"</td>\n  </tr>\n</table>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatTableDataSource, MatTableModule} from '@angular/material/table';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\nexport interface PeriodicElement {\n  name: string;\n  position: number;\n  weight: number;\n  symbol: string;\n}\n\nconst ELEMENT_DATA: PeriodicElement[] = [\n  {position: 1, name: 'Hydrogen', weight: 1.0079, symbol: 'H'},\n  {position: 2, name: 'Helium', weight: 4.0026, symbol: 'He'},\n  {position: 3, name: 'Lithium', weight: 6.941, symbol: 'Li'},\n  {position: 4, name: 'Beryllium', weight: 9.0122, symbol: 'Be'},\n  {position: 5, name: 'Boron', weight: 10.811, symbol: 'B'},\n  {position: 6, name: 'Carbon', weight: 12.0107, symbol: 'C'},\n  {position: 7, name: 'Nitrogen', weight: 14.0067, symbol: 'N'},\n  {position: 8, name: 'Oxygen', weight: 15.9994, symbol: 'O'},\n  {position: 9, name: 'Fluorine', weight: 18.9984, symbol: 'F'},\n  {position: 10, name: 'Neon', weight: 20.1797, symbol: 'Ne'},\n];\n\n/**\n * @title Table with filtering\n */\n@Component({\n  selector: 'table-filtering-example',\n  styleUrl: 'table-filtering-example.css',\n  templateUrl: 'table-filtering-example.html',\n  standalone: true,\n  imports: [MatFormFieldModule, MatInputModule, MatTableModule],\n})\nexport class TableFilteringExample {\n  displayedColumns: string[] = ['position', 'name', 'weight', 'symbol'];\n  dataSource = new MatTableDataSource(ELEMENT_DATA);\n\n  applyFilter(event: Event) {\n    const filterValue = (event.target as HTMLInputElement).value;\n    this.dataSource.filter = filterValue.trim().toLowerCase();\n  }\n}"}, 'overview.txt': 'The mat-table provides a Material Design styled data-table that can be used to display rows of data.\n\nThis table builds on the foundation of the CDK data-table and uses a similar interface for its data input and template, except that its element and attribute selectors will be prefixed with mat- instead of cdk-. For more information on the interface and a detailed look at how the table is implemented, see the guide covering the CDK data-table.\n\n1. Write your mat-table and provide data\nBegin by adding the <table mat-table> component to your template and passing in data.\n\nThe simplest way to provide data to the table is by passing a data array to the table\'s dataSource input. The table will take the array and render a row for each object in the data array.\n\n<table mat-table [dataSource]="myDataArray">\n  ...\n</table>\nSince the table optimizes for performance, it will not automatically check for changes to the data array. Instead, when objects are added, removed, or moved on the data array, you can trigger an update to the table\'s rendered rows by calling its renderRows() method.\n\nWhile an array is the simplest way to bind data into the data source, it is also the most limited. For more complex applications, using a DataSource instance is recommended. See the section "Advanced data sources" below for more information.\n\n2. Define the column templates\nNext, write your table\'s column templates.\n\nEach column definition should be given a unique name and contain the content for its header and row cells.\n\nHere\'s a simple column definition with the name \'score\'. The header cell contains the text "Score" and each row cell will render the score property of each row\'s data.\n\n<ng-container matColumnDef="score">\n  <th mat-header-cell *matHeaderCellDef> Score </th>\n  <td mat-cell *matCellDef="let user"> {{user.score}} </td>\n</ng-container>\nNote that the cell templates are not restricted to only showing simple string values, but are flexible and allow you to provide any template.\n\nIf your column is only responsible for rendering a single string value for the header and cells, you can instead define your column using the mat-text-column. The following column definition is equivalent to the one above.\n\n<mat-text-column name="score"></mat-text-column>\nCheck out the API docs and examples of the mat-text-column to see how you can customize the header text, text alignment, and cell data accessor. Note that this is not compatible with the flex-layout table. Also, a data accessor should be provided if your data may have its properties minified since the string name will no longer match after minification.\n\n3. Define the row templates\nFinally, once you have defined your columns, you need to tell the table which columns will be rendered in the header and data rows.\n\nTo start, create a variable in your component that contains the list of the columns you want to render.\n\ncolumnsToDisplay = [\'userName\', \'age\'];\nThen add mat-header-row and mat-row to the content of your mat-table and provide your column list as inputs.\n\n<tr mat-header-row *matHeaderRowDef="columnsToDisplay"></tr>\n<tr mat-row *matRowDef="let myRowData; columns: columnsToDisplay"></tr>\nNote that this list of columns provided to the rows can be in any order, not necessarily the order in which you wrote the column definitions. Also, you do not necessarily have to include every column that was defined in your template.\n\nThis means that by changing your column list provided to the rows, you can easily re-order and include/exclude columns dynamically.\n\nAdvanced data sources\nThe simplest way to provide data to your table is by passing a data array. More complex use-cases may benefit from a more flexible approach involving an Observable stream or by encapsulating your data source logic into a DataSource class.\n\n Observable stream of data arrays\nAn alternative approach to providing data to the table is by passing an Observable stream that emits the data array to be rendered each time it is changed. The table will listen to this stream and automatically trigger an update to the rows each time a new data array is emitted.\n\n DataSource\nFor most real-world applications, providing the table a DataSource instance will be the best way to manage data. The DataSource is meant to serve as a place to encapsulate any sorting, filtering, pagination, and data retrieval logic specific to the application.\n\nA DataSource is simply a class that has at a minimum the following methods: connect and disconnect. The connect method will be called by the table to provide an Observable that emits the data array that should be rendered. The table will call disconnect when the table is destroyed, which may be the right time to clean up any subscriptions that may have been registered in the connect method.\n\nAlthough Angular Material provides a ready-made table DataSource class, MatTableDataSource, you may want to create your own custom DataSource class for more complex use cases. This can be done by extending the abstract DataSource class with a custom DataSource class that then implements the connect and disconnect methods. For use cases where the custom DataSource must also inherit functionality by extending a different base class, the DataSource base class can be implemented instead (MyCustomDataSource extends SomeOtherBaseClass implements DataSource) to respect Typescript\'s restriction to only implement one base class.\n\n Styling Columns\nEach table cell has an automatically generated class based on which column it appears in. The format for this generated class is mat-column-NAME. For example, cells in a column named "symbol" can be targeted with the selector .mat-column-symbol.\n\nRow Templates\nEvent handlers and property binding on the row templates will be applied to each row rendered by the table. For example, adding a (click) handler to the row template will cause each individual row to call the handler when clicked.\n\nFeatures\nThe MatTable is focused on a single responsibility: efficiently render rows of data in a performant and accessible way.\n\nYou\'ll notice that the table itself doesn\'t come out of the box with a lot of features, but expects that the table will be included in a composition of components that fills out its features.\n\nFor example, you can add sorting and pagination to the table by using MatSort and MatPaginator and mutating the data provided to the table according to their outputs.\n\nTo simplify the use case of having a table that can sort, paginate, and filter an array of data, the Angular Material library comes with a MatTableDataSource that has already implemented the logic of determining what rows should be rendered according to the current table state. To add these feature to the table, check out their respective sections below.\n\n Pagination\nTo paginate the table\'s data, add a <mat-paginator> after the table.\nIf you are using the MatTableDataSource for your table\'s data source, simply provide the MatPaginator to your data source. It will automatically listen for page changes made by the user and send the right paged data to the table.\nOtherwise if you are implementing the logic to paginate your data, you will want to listen to the paginator\'s (page) output and pass the right slice of data to your table.\nFor more information on using and configuring the <mat-paginator>, check out the mat-paginator docs.\nThe MatPaginator is one provided solution to paginating your table\'s data, but it is not the only option. In fact, the table can work with any custom pagination UI or strategy since the MatTable and its interface is not tied to any one specific implementation.\n\nSorting\nTo add sorting behavior to the table, add the matSort directive to the table and add mat-sort-header to each column header cell that should trigger sorting. Note that you have to import MatSortModule in order to initialize the matSort directive (see API docs).\n\n<!-- Name Column -->\n<ng-container matColumnDef="position">\n  <th mat-header-cell *matHeaderCellDef mat-sort-header> Name </th>\n  <td mat-cell *matCellDef="let element"> {{element.position}} </td>\n</ng-container>\nIf you are using the MatTableDataSource for your table\'s data source, provide the MatSort directive to the data source and it will automatically listen for sorting changes and change the order of data rendered by the table.\n\nBy default, the MatTableDataSource sorts with the assumption that the sorted column\'s name matches the data property name that the column displays. For example, the following column definition is named position, which matches the name of the property displayed in the row cell.\nNote that if the data properties do not match the column names, or if a more complex data property accessor is required, then a custom sortingDataAccessor function can be set to override the default data accessor on the MatTableDataSource.\nIf you are not using the MatTableDataSource, but instead implementing custom logic to sort your data, listen to the sort\'s (matSortChange) event and re-order your data according to the sort state. If you are providing a data array directly to the table, don\'t forget to call renderRows() on the table, since it will not automatically check the array for changes.\n\nFor more information on using and configuring the sorting behavior, check out the matSort docs.\n\nThe MatSort is one provided solution to sorting your table\'s data, but it is not the only option. In fact, the table can work with any custom sorting UI or strategy since the MatTable and its interface is not tied to any one specific implementation.\n\n Filtering\nAngular Material does not provide a specific component to be used for filtering the MatTable since there is no single common approach to adding a filter UI to table data.\nA general strategy is to add an input where users can type in a filter string and listen to this input to change what data is offered from the data source to the table.\nIf you are using the MatTableDataSource, simply provide the filter string to the MatTableDataSource. The data source will reduce each row data to a serialized form and will filter out the row if it does not contain the filter string. By default, the row data reducing function will concatenate all the object values and convert them to lowercase.\nFor example, the data object {id: 123, name: \'Mr. Smith\', favoriteColor: \'blue\'} will be reduced to 123mr. smithblue. If your filter string was blue then it would be considered a match because it is contained in the reduced string, and the row would be displayed in the table.\nTo override the default filtering behavior, a custom filterPredicate function can be set which takes a data object and filter string and returns true if the data object is considered a match.\nIf you want to show a message when not data matches the filter, you can use the *matNoDataRow directive.\n\nAccessibility\nBy default, MatTable applies role="table", assuming the table\'s contains primarily static content. You can change the role by explicitly setting role="grid" or role="treegrid" on the table element. While changing the role will update child element roles, such as changing role="cell" to role="gridcell", this does not apply additional keyboard input handling or focus management to the table.\n\nAlways provide an accessible label for your tables via aria-label or aria-labelledby on the table element.\n\n Tables with display: flex\nThe MatTable does not require that you use a native HTML table. Instead, you can use an alternative approach that uses display: flex for the table\'s styles.\n\nThis alternative approach replaces the native table element tags with the MatTable directive selectors. For example, <table mat-table> becomes <mat-table>; <tr mat-row> becomes <mat-row>. The following shows a previous example using this alternative template:\n\n<mat-table [dataSource]="dataSource">\n  <!-- User name Definition -->\n  <ng-container matColumnDef="username">\n    <mat-header-cell *matHeaderCellDef> User name </mat-header-cell>\n    <mat-cell *matCellDef="let row"> {{row.username}} </mat-cell>\n  </ng-container>\n\n  <!-- Age Definition -->\n  <ng-container matColumnDef="age">\n    <mat-header-cell *matHeaderCellDef> Age </mat-header-cell>\n    <mat-cell *matCellDef="let row"> {{row.age}} </mat-cell>\n  </ng-container>\n\n  <!-- Title Definition -->\n  <ng-container matColumnDef="title">\n    <mat-header-cell *matHeaderCellDef> Title </mat-header-cell>\n    <mat-cell *matCellDef="let row"> {{row.title}} </mat-cell>\n  </ng-container>\n\n  <!-- Header and Row Declarations -->\n  <mat-header-row *matHeaderRowDef="[\'username\', \'age\', \'title\']"></mat-header-row>\n  <mat-row *matRowDef="let row; columns: [\'username\', \'age\', \'title\']"></mat-row>\n</mat-table>\nNote that this approach means you cannot include certain native-table features such colspan/rowspan or have columns that resize themselves based on their content.\n\n Tables with MatRipple\nBy default, MatTable does not set up Material Design ripples for rows. A ripple effect can be added to table rows by using the MatRipple directive from @angular/material/core. Due to limitations in browsers, ripples cannot be applied native th or tr elements. The recommended approach for setting up ripples is using the non-native display: flex variant of MatTable.'}, 'tabs': {'Basic use of the tab group': {'HTML.html': '<mat-tab-group>\n  <mat-tab label="First"> Content 1 </mat-tab>\n  <mat-tab label="Second"> Content 2 </mat-tab>\n  <mat-tab label="Third"> Content 3 </mat-tab>\n</mat-tab-group>', 'TS.ts': "import {Component} from '@angular/core';\nimport {MatTabsModule} from '@angular/material/tabs';\n\n/**\n * @title Basic use of the tab group\n */\n@Component({\n  selector: 'tab-group-basic-example',\n  templateUrl: 'tab-group-basic-example.html',\n  standalone: true,\n  imports: [MatTabsModule],\n})\nexport class TabGroupBasicExample {}"}, 'Tab group with asynchronously loading tab contents': {'HTML.html': '@if ((asyncTabs | async) === null) {\n  Loading tabs...\n}\n\n<mat-tab-group>\n  @for (tab of asyncTabs | async; track tab) {\n    <mat-tab>\n      <ng-template mat-tab-label>{{tab.label}}</ng-template>\n      {{tab.content}}\n    </mat-tab>\n  }\n</mat-tab-group>', 'TS.ts': "import {Component} from '@angular/core';\nimport {Observable, Observer} from 'rxjs';\nimport {MatTabsModule} from '@angular/material/tabs';\nimport {AsyncPipe} from '@angular/common';\n\nexport interface ExampleTab {\n  label: string;\n  content: string;\n}\n\n/**\n * @title Tab group with asynchronously loading tab contents\n */\n@Component({\n  selector: 'tab-group-async-example',\n  templateUrl: 'tab-group-async-example.html',\n  standalone: true,\n  imports: [MatTabsModule, AsyncPipe],\n})\nexport class TabGroupAsyncExample {\n  asyncTabs: Observable<ExampleTab[]>;\n\n  constructor() {\n    this.asyncTabs = new Observable((observer: Observer<ExampleTab[]>) => {\n      setTimeout(() => {\n        observer.next([\n          {label: 'First', content: 'Content 1'},\n          {label: 'Second', content: 'Content 2'},\n          {label: 'Third', content: 'Content 3'},\n        ]);\n      }, 1000);\n    });\n  }\n}"}, 'overview.txt': 'Angular Material tabs organize content into separate views where only one view can be visible at a time. Each tab\'s label is shown in the tab header and the active tab\'s label is designated with the animated ink bar. When the list of tab labels exceeds the width of the header, pagination controls appear to let the user scroll left and right across the labels.\nThe active tab may be set using the selectedIndex input or when the user selects one of the tab labels in the header.\n\nEvents\nThe selectedTabChange output event is emitted when the active tab changes.\n\nThe focusChange output event is emitted when the user puts focus on any of the tab labels in the header, usually through keyboard navigation.\n\n Labels\nIf a tab\'s label is only text then the simple tab-group API can be used.\n\n<mat-tab-group>\n  <mat-tab label="First"> Content 1 </mat-tab>\n  <mat-tab label="Second"> Content 2 </mat-tab>\n  <mat-tab label="Third"> Content 3 </mat-tab>\n</mat-tab-group>\nFor more complex labels, add a template with the mat-tab-label directive inside the mat-tab.\n\n<ng-template mat-tab-label>\n  <mat-icon class="example-tab-icon">thumb_up</mat-icon>\n  First\n</ng-template>\n Dynamic Height\nBy default, the tab group will not change its height to the height of the currently active tab. To change this, set the dynamicHeight input to true. The tab body will animate its height according to the height of the active tab.\n\n<mat-tab-group dynamicHeight>\n Tabs and navigation\nWhile <mat-tab-group> is used to switch between views within a single route, <nav mat-tab-nav-bar> provides a tab-like UI for navigating between routes.\n\n<nav mat-tab-nav-bar [backgroundColor]="background" [tabPanel]="tabPanel">\n  @for (link of links; track link) {\n    <a mat-tab-link\n      (click)="activeLink = link"\n      [active]="activeLink == link"> {{link}} </a>\n  }\n  <a mat-tab-link disabled>Disabled Link</a>\n</nav>\n<mat-tab-nav-panel #tabPanel></mat-tab-nav-panel>\nThe mat-tab-nav-bar is not tied to any particular router; it works with normal <a> elements and uses the active property to determine which tab is currently active. The corresponding <router-outlet> must be wrapped in an <mat-tab-nav-panel> component and should typically be placed relatively close to the mat-tab-nav-bar (see Accessibility).\n\n Lazy Loading\nBy default, the tab contents are eagerly loaded. Eagerly loaded tabs will initialize the child components but not inject them into the DOM until the tab is activated.\n\nIf the tab contains several complex child components or the tab\'s contents rely on DOM calculations during initialization, it is advised to lazy load the tab\'s content.\n\nTab contents can be lazy loaded by declaring the body in a ng-template with the matTabContent attribute.\n\n<mat-tab label="First">\n  <ng-template matTabContent>\n    Content 1 - Loaded: {{getTimeLoaded(1) | date:\'medium\'}}\n  </ng-template>\n</mat-tab>\n Label alignment\nIf you want to align the tab labels in the center or towards the end of the container, you can do so using the [mat-align-tabs] attribute.\n\n<mat-tab-group mat-stretch-tabs="false" mat-align-tabs="start">\n Controlling the tab animation\nYou can control the duration of the tabs\' animation using the animationDuration input. If you want to disable the animation completely, you can do so by setting the properties to 0ms. The duration can be configured globally using the MAT_TABS_CONFIG injection token.\n\n<mat-tab-group animationDuration="2000ms">\n Keeping the tab content inside the DOM while it\'s off-screen\nBy default the <mat-tab-group> will remove the content of off-screen tabs from the DOM until they come into the view. This is optimal for most cases since it keeps the DOM size smaller, but it isn\'t great for others like when a tab has an <audio> or <video> element, because the content will be re-initialized whenever the user navigates to the tab. If you want to keep the content of off-screen tabs in the DOM, you can set the preserveContent input to true.\n\nAccessibility\nMatTabGroup and MatTabNavBar both implement the ARIA Tabs design pattern. Both components compose tablist, tab, and tabpanel elements with handling for keyboard inputs and focus management.\n\nWhen using MatTabNavBar, you should place the <mat-tab-nav-panel> component relatively close to if not immediately adjacent to the <nav mat-tab-nav-bar> component so that it\'s easy for screen reader users to identify the association.\n\n Labels\nAlways provide an accessible label via aria-label or aria-describedby for tabs without descriptive text content.\nWhen using MatTabNavGroup, always specify a label for the <nav> element.'}, 'tooltip': {'Tooltip with a custom position': {'CSS.css': '.example-user-input {\n  margin-right: 8px;\n}', 'HTML.html': '<mat-form-field class="example-user-input">\n  <mat-label>Tooltip position</mat-label>\n  <mat-select [formControl]="position">\n    @for (positionOption of positionOptions; track positionOption) {\n      <mat-option [value]="positionOption">{{positionOption}}</mat-option>\n    }\n  </mat-select>\n</mat-form-field>\n\n<button mat-raised-button\n        matTooltip="Info about the action"\n        [matTooltipPosition]="position.value!"\n        aria-label="Button that displays a tooltip in various positions">\n  Action\n</button>', 'TS.ts': "import {Component} from '@angular/core';\nimport {FormControl, FormsModule, ReactiveFormsModule} from '@angular/forms';\nimport {TooltipPosition, MatTooltipModule} from '@angular/material/tooltip';\nimport {MatButtonModule} from '@angular/material/button';\nimport {MatSelectModule} from '@angular/material/select';\nimport {MatFormFieldModule} from '@angular/material/form-field';\n\n/**\n * @title Tooltip with a custom position\n */\n@Component({\n  selector: 'tooltip-position-example',\n  templateUrl: 'tooltip-position-example.html',\n  styleUrl: 'tooltip-position-example.css',\n  standalone: true,\n  imports: [\n    MatFormFieldModule,\n    MatSelectModule,\n    FormsModule,\n    ReactiveFormsModule,\n    MatButtonModule,\n    MatTooltipModule,\n  ],\n})\nexport class TooltipPositionExample {\n  positionOptions: TooltipPosition[] = ['after', 'before', 'above', 'below', 'left', 'right'];\n  position = new FormControl(this.positionOptions[0]);\n}"}, 'overview.txt': "The Angular Material tooltip provides a text label that is displayed when the user hovers over or longpresses an element.\n\nPositioning\nThe tooltip will be displayed below the element but this can be configured using the matTooltipPosition input. The tooltip can be displayed above, below, left, or right of the element. By default the position will be below. If the tooltip should switch left/right positions in an RTL layout direction, then the positions before and after should be used instead of left and right, respectively.\n\nPosition\tDescription\nabove\tAlways display above the element\nbelow\tAlways display beneath the element\nleft\tAlways display to the left of the element\nright\tAlways display to the right of the element\nbefore\tDisplay to the left in left-to-right layout and to the right in right-to-left layout\nafter\tDisplay to the right in left-to-right layout and to the left in right-to-left layout\nBased on the position in which the tooltip is shown, the .mat-tooltip-panel element will receive a CSS class that can be used for style (e.g. to add an arrow). The possible classes are mat-tooltip-panel-above, mat-tooltip-panel-below, mat-tooltip-panel-left, mat-tooltip-panel-right.\n\nTo display the tooltip relative to the mouse or touch that triggered it, use the matTooltipPositionAtOrigin input. With this setting turned on, the tooltip will display relative to the origin of the trigger rather than the host element. In cases where the tooltip is not triggered by a touch event or mouse click, it will display the same as if this setting was turned off.\n\n Showing and hiding\nBy default, the tooltip will be immediately shown when the user's mouse hovers over the tooltip's trigger element and immediately hides when the user's mouse leaves.\n\nOn mobile, the tooltip is displayed when the user longpresses the element and hides after a delay of 1500ms.\n\nDisabling the tooltip from showing\nTo completely disable a tooltip, set matTooltipDisabled. While disabled, a tooltip will never be shown.\n\n Accessibility\nMatTooltip adds an aria-describedby description that provides a reference to a visually hidden element containing the tooltip's message. This provides screen-readers the information needed to read out the tooltip's contents when the end-user focuses on tooltip's trigger. The element referenced by aria-describedby is not the tooltip itself, but instead an invisible copy of the tooltip content that is always present in the DOM.\nAvoid interactions that exclusively show a tooltip with pointer events like click and mouseenter. Always ensure that keyboard users can perform the same set of actions available to mouse and touch users."}}}